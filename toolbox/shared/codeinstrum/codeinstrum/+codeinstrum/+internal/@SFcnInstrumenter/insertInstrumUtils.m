



function extraFiles=insertInstrumUtils(this,instrumentedFiles,mexPath)

    if nargin<3||isempty(mexPath)
        forOriginalMain=false;
    else
        forOriginalMain=true;
    end


    extraFiles={};


    instrObj=this.InstrumObj;
    instrVarRadix=instrObj.InstrVarRadix;
    dbFile=instrObj.getDbFilePath();



    mexMacroTxt=iGetMexMacros(this);

    mxApiInfo=this.getMxApiInfo();

    if forOriginalMain



        mainFile=instrumentedFiles{1};
        [~,~,fExt]=fileparts(mainFile);
        isCxx=strcmpi(fExt,'.cpp');
        extraFiles{1}=this.generateInstrumDbDataFile(isCxx);
        instrCodeDeclTxt=this.getInstrumDbDataDeclarations();


        [extraFiles{2},instrCodeDeclTxt1]=iGenerateBinDumpFile(this,mexPath,isCxx);
        instrCodeDeclTxt=sprintf([...
        instrCodeDeclTxt,'\n',...
        instrCodeDeclTxt1]);

        extraCodeDefTxt=sprintf([...
        '         else if (strcmp(%scmd, "getInstrumentedMex")==0) {                                        \n',...
        '            if (nlhs==1) {                                                                         \n',...
        '                plhs[0] = ',mxApiInfo.mxCreateNumericMatrix,'(1, %s_instrumented_mex_len, mxUINT8_CLASS, mxREAL);\n',...
        '                (void)memcpy(',mxApiInfo.mxGetData,'(plhs[0]), %s_instrumented_mex_ptr, %s_instrumented_mex_len);\n',...
        '                return 1;                                                                          \n',...
        '            }                                                                                      \n',...
        '         }'],...
        instrVarRadix,instrVarRadix,instrVarRadix,instrVarRadix);


        hasSldvInfo=0;
        sldvChecksum='';
        if~isempty(this.SLDVInfo)&&~isempty(this.SLDVChecksum)
            sldvChecksum=this.SLDVChecksum;
            hasSldvInfo=1;
        end
        extraCodeDefTxt=sprintf(['%s\n',...
        '     else if (strcmp(%scmd, "isSldvCompatible")==0) {            \n',...
        '        if (nlhs==1) {                                           \n',...
        '            plhs[0] = ',mxApiInfo.mxCreateLogicalScalar,'(%d); \n',...
        '            return 1;                                            \n',...
        '        }                                                        \n',...
        '     } else if (strcmp(%scmd, "getSldvSupportVersionStr")==0) {  \n',...
        '        if (nlhs==1) {                                           \n',...
        '            (void)sprintf(%smsg, "1.1.0");                       \n',...
        '            plhs[0] = ',mxApiInfo.mxCreateString,'(%smsg);     \n',...
        '            return 1;                                            \n',...
        '        }                                                        \n',...
        '     } else if (strcmp(%scmd, "getSldvChecksum")==0) {           \n',...
        '        if (nlhs==1) {                                           \n',...
        '            (void)sprintf(%smsg, "%s");                          \n',...
        '            plhs[0] = ',mxApiInfo.mxCreateString,'(%smsg);     \n',...
        '            return 1;                                            \n',...
        '        }                                                        \n',...
'     } '...
        ],extraCodeDefTxt,instrVarRadix,hasSldvInfo,instrVarRadix,instrVarRadix,...
        instrVarRadix,instrVarRadix,instrVarRadix,sldvChecksum,instrVarRadix);



        cmdLineStr=this.getMexCommandLineHandlerBodyStr(extraCodeDefTxt);
        sep='\\\n';
        cmdLineStr=regexprep(cmdLineStr,'\n',[' ',sep]);
        if strcmpi(cmdLineStr(end-1:end),sprintf(sep))
            sep='';
        end



        dynLoadHelpersTxt=[...
        'static SimStruct *%sgetSimStruct(const mxArray *prhs[])\n',...
        '{\n',...
        '  size_t m = ',mxApiInfo.mxGetM,'(prhs[_RHS_X]);\n',...
        '  real_T *pr = ((m == (sizeof(SimStruct *) / sizeof(int_T) + 1)) ?\n',...
        '                (real_T *) ',mxApiInfo.mxGetPr,'(prhs[_RHS_X]) :\n',...
        '                (real_T *) 0);\n',...
        '  if (pr && (pr[m - 1] == SIMSTRUCT_VERSION_LEVEL2)) {\n',...
        '    int_T intSptr[sizeof(SimStruct *) / sizeof(int_T)];\n',...
        '    size_t i;\n',...
        '    SimStruct *S;\n',...
        '    for (i = 0; i < sizeof(intSptr) / sizeof(*intSptr); ++i) {\n',...
        '      intSptr[i] = (int_T) pr[i];\n',...
        '    }\n',...
        '    memcpy(&S, intSptr, sizeof(intSptr));\n',...
        '    return S;\n',...
        '  }\n',...
        '  return 0;\n',...
        '}\n\n',...
        'static slcovMxFunctionRef *%smexRef = 0;\n\n',...
        'static void %sunloadInstrumentedMex(void)\n',...
        '{\n',...
        '  slcovUnloadInstrumentedMexFunction(&%smexRef);\n',...
        '}\n'];
        n=sum(dynLoadHelpersTxt=='%');
        dynLoadHelpersFormatArgs=repmat({instrVarRadix},[1,n]);




        loadHookTxt=[...
        'if ((nlhs >= 0 && nlhs <= 1) && (nrhs >= 4) &&                                                         \\\n',...
        '    ',mxApiInfo.mxIsDouble,'(prhs[_RHS_FLAG]) && !',mxApiInfo.mxIsComplex,'(prhs[_RHS_FLAG]) &&    \\\n',...
        '    (',mxApiInfo.mxGetNumberOfElements,'(prhs[_RHS_FLAG]) == 1) && (*',mxApiInfo.mxGetPr,'(prhs[_RHS_FLAG]) == 0.0)) { \\\n',...
        '    SimStruct *S = %sgetSimStruct(prhs);                                                               \\\n',...
        '    if (slcovLoadInstrumentedMexFunction(S, &%smexRef)) {                                              \\\n',...
        '        mexAtExit(%sunloadInstrumentedMex);                                                            \\\n',...
        '    }                                                                                                  \\\n',...
        '}                                                                                                      \\\n',...
        'if (%smexRef) {                                                                                        \\\n',...
        '    slcovRunInstrumentedMexFunction(%smexRef, nlhs, plhs, nrhs, prhs);                                 \\\n',...
        '    return 1;                                                                                          \\\n',...
        '}                                                                                                      \\\n'];
        n=sum(loadHookTxt=='%');
        loadHookFormatArgs=repmat({instrVarRadix},[1,n]);

        instrCodeDefTxt=[mexMacroTxt,sprintf([...
        '\n',...
        dynLoadHelpersTxt,'\n',...
        '#define __MW_INSTRUM_PROC_MEX_SFUN_CMD_LINE(nlhs, plhs, nrhs, prhs)     \\\n',...
        'do {                                                                                 \\\n',...
        '%s ',sep,...
        loadHookTxt,...
        '} while(0)\n'],...
        dynLoadHelpersFormatArgs{:},...
        cmdLineStr,...
        loadHookFormatArgs{:})];


        if~this.SFcnInfo.hasProcessMexEveryCall
            instrCodeDefTxt=[instrCodeDefTxt,sprintf([...
            '\nint_T ProcessMexSfunctionEveryCall(int_T nlhs, mxArray* plhs[], int_T nrhs, const mxArray* prhs[]) {\n',...
            '    __MW_INSTRUM_PROC_MEX_SFUN_CMD_LINE(nlhs, plhs, nrhs, prhs);\n',...
            '    return 0;\n',...
            '}\n',...
            ])];
        end
    else



        mainFile=instrumentedFiles{this.SFcnInfo.idxMain(1)}{this.SFcnInfo.idxMain(2)};



        if~isempty(this.SLDVInfo)
            ctx=this.setupContext();
            ctx=this.updateContextForSource(ctx,this.SFcnInfo.idxMain(1),this.SFcnInfo.idxMain(2));
            this.SLDVChecksum=this.SLDVInfo.updateTraceabilityDb(dbFile,this.BuildOptions,...
            instrumentedFiles,this.SFcnInfo,this.WorkingDir,ctx.feOpts);
        end


        instrCodeDeclTxt=instrObj.getInstrumDataDefinitions();


        instrDataInfo=instrObj.getInstrumDataInfo();

        upLoadMacro=sprintf([...
        '#define __MW_INSTRUM_SFCNUPLOAD_COVERAGE_SYNTHESIS(X) ',...
        'slcovUploadSFunctionCoverageSynthesis((X), %s, %s, 0, 0)\n',...
        ],...
        instrDataInfo.vHitsSize.name,...
        instrDataInfo.vHits.name);

        enterMacro=[...
        '#define __MW_INSTRUM_SFCNMETHOD_ENTER(X) ',...
        '(void)slcovEnterSFunctionMethod((X))',...
newline...
        ];

        startMacro=sprintf([...
        '#define __MW_INSTRUM_SFCNMETHOD_ENTER_START(X) (',...
        '(void)slcovStartRecording((X)), ',...
        '%s = slcovGetCovBoundaryAbsTol(), ',...
        '%s = slcovGetCovBoundaryRelTol(), ',...
'__MW_INSTRUM_SFCNMETHOD_ENTER((X))'...
        ,')\n',...
        ],...
        instrDataInfo.vAbsTol.name,...
        instrDataInfo.vRelTol.name);

        exitMacro=[...
        '#define __MW_INSTRUM_SFCNMETHOD_EXIT(X) (',...
        '__MW_INSTRUM_SFCNUPLOAD_COVERAGE_SYNTHESIS((X)), (void)slcovExitSFunctionMethod((X))',...
        ')',...
newline...
        ];

        terminateMacro=[...
        '#define __MW_INSTRUM_SFCNMETHOD_EXIT_TERMINATE(X) (',...
        '__MW_INSTRUM_SFCNMETHOD_EXIT((X)), ',...
        '(void)slcovStopRecording((X))',...
        ')',...
newline...
        ];

        instrCodeDefTxt=[...
        mexMacroTxt,...
        newline,...
        upLoadMacro,...
        enterMacro,...
        startMacro,...
        exitMacro,...
terminateMacro...
        ];


        if~this.SFcnInfo.hasMdlStart
            instrCodeDefTxt=[instrCodeDefTxt,sprintf([...
            '\nvoid mdlStart(SimStruct *S) {\n',...
            '    __MW_INSTRUM_SFCNMETHOD_ENTER_START(S);\n',...
            '    __MW_INSTRUM_SFCNMETHOD_EXIT(S);\n',...
'}\n'...
            ])];
        end
    end


    iPatchSFunctionMainTranslationUnit(mainFile,instrCodeDeclTxt,instrCodeDefTxt);

end


function txt=iGetMexMacros(this)

    txt='';
    for ii=1:numel(this.SFcnInfo.mexDefines)
        tok=regexp(this.SFcnInfo.mexDefines{ii},'#define\s+(\w+)','tokens');
        startGuard='';
        endGuard='';
        if~isempty(tok)&&iscell(tok{1})&&~isempty(tok{1})&&~isempty(tok{1}{1})
            startGuard=sprintf('#ifndef %s\n',tok{1}{1});
            endGuard=sprintf('\n#endif\n');
        end
        txt=sprintf('%s%s%s%s\n',...
        txt,startGuard,this.SFcnInfo.mexDefines{ii},endGuard);
    end

end


function iPatchSFunctionMainTranslationUnit(mainFile,instrCodeDeclTxt,instrCodeDefTxt)


    [fid,errMsg]=fopen(mainFile,'rb');
    if fid<0||~isempty(errMsg)
        codeinstrum.internal.error('CodeInstrumentation:utils:openForReadingError',mainFile,errMsg);
    end
    mainFileContents=fread(fid,Inf,'*uint8')';
    fclose(fid);


    [fid,errMsg]=fopen(mainFile,'wb');
    if fid<0||~isempty(errMsg)
        codeinstrum.internal.error('CodeInstrumentation:utils:openForWritingError',mainFile,errMsg);
    end



    regexpPat='(extern\s+\"C\"\s*\{\s*)?extern\s*(\"C\")?\s*real_T\s*\*\s*\_ssGetAbsTol\s*\(\s*SimStruct\s*\*\s*S\s*\)\s*;';
    idx=regexp(char(mainFileContents),regexpPat,'start');
    if~isempty(idx)
        fwrite(fid,mainFileContents(1:idx(1)-1),'*uint8');
        fprintf(fid,'\n%s\n%s\n',instrCodeDeclTxt,instrCodeDefTxt);
        fwrite(fid,mainFileContents(idx(1):end),'*uint8');
    end

    fclose(fid);

end


function[fName,extraVarDeclStr]=iGenerateBinDumpFile(this,mexPath,isCxx)


    fext='.c';
    if isCxx
        fext='.cpp';
    end


    fName=[tempname(this.WorkingDir),fext];
    [fid,errMsg]=fopen(fName,'wt');
    if fid<0||~isempty(errMsg)
        codeinstrum.internal.error('CodeInstrumentation:utils:openForReadingError',fName,errMsg);
    end
    clr=onCleanup(@()fclose(fid));


    radixVarStr=this.InstrumObj.InstrVarRadix;
    fprintf(fid,'#include "mex.h"\n\n');
    fprintf(fid,[...
    'static const uint8_T %s_instrumented_mex[] = {\n%s\n};\n',...
    '%s\n',...
    'const mwSize %s_instrumented_mex_len = sizeof(%s_instrumented_mex)/sizeof(uint8_T);\n\n',...
    '%s\n',...
    'const uint8_T* %s_instrumented_mex_ptr = &%s_instrumented_mex[0];\n',...
    '%s\n\n',...
    ],...
    radixVarStr,iGetInstrumentedMexAsString(mexPath),...
    codeinstrum.internal.Instrumenter.EXTERN_C_DEF_STR,...
    radixVarStr,radixVarStr,...
    codeinstrum.internal.Instrumenter.EXTERN_C_BLOCK_START_STR,...
    radixVarStr,radixVarStr,...
    codeinstrum.internal.Instrumenter.EXTERN_C_BLOCK_END_STR);

    extraVarDeclStr=sprintf([...
    '%s\nconst uint8_T* %s_instrumented_mex_ptr;\n',...
'%s\nconst mwSize %s_instrumented_mex_len;\n'...
    ],...
    codeinstrum.internal.Instrumenter.EXTERN_C_DECL_STR,radixVarStr,...
    codeinstrum.internal.Instrumenter.EXTERN_C_DECL_STR,radixVarStr);

end


function res=iGetInstrumentedMexAsString(mexPath)

    mexPath=polyspace.internal.getAbsolutePath(mexPath);

    [fid,errMsg]=fopen(mexPath,'rb');
    if fid<0||~isempty(errMsg)
        codeinstrum.internal.error('CodeInstrumentation:utils:openForReadingError',mexPath,errMsg);
    end

    arr=fread(fid,Inf,'*uint8');
    fclose(fid);

    res=codeinstrum.internal.Utils.formatBytesAsString(arr);

end




