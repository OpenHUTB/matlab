classdef ColorConversion






    methods(Static)
        function val=validatecolorspecs(val,fcnName,propName)


            if iscell(val)
                for i=1:numel(val)
                    val{i}=internal.ColorConversion.validatecolorspec(...
                    val{i},fcnName,propName);
                end
            elseif ismatrix(val)
                validateattributes(val,{'double','single'},...
                {'finite','real','nonnegative',...
                'ncols',3,'<=',1},...
                fcnName,propName);
            else
                val=internal.ColorConversion.validatecolorspec(...
                val,fcnName,propName);
            end
        end

        function val=validatecolorspec(val,fcnName,propName)








            if ischar(val)||(isstring(val)&&isscalar(val))
                val=validatestring(val,...
                {'r','g','b','c','m','y','k','w',...
                'red','green','blue','cyan','magenta','yellow',...
                'black','white'},fcnName,propName);
            else
                validateattributes(val,{'double','single'},...
                {'finite','real','nonnegative',...
                'size',[1,3],'<=',1},...
                fcnName,propName);
            end
        end

        function bw=getBWContrast(c)








            c=internal.ColorConversion.getRGBFromColor(c);
            yiq=c*[299;587;114]/1000;
            if yiq>0.7




                bw='k';
            else
                bw='w';
            end
        end

        function d=getRGBFromColor(c)





            if iscell(c)
                Nc=numel(c);
                d=zeros(Nc,3);
                for i=1:Nc
                    d(i,:)=internal.ColorConversion.getRGBFromColor(c{i});
                end

            elseif ischar(c)||(isstring(c)&&isscalar(c))
                switch lower(c(1))
                case 'w',d=[1,1,1];
                case 'r',d=[1,0,0];
                case 'g',d=[0,1,0];
                case 'b'
                    if size(c)==1
                        d=[0,0,1];
                    else
                        if contains('blue',c)
                            d=[0,0,1];
                        elseif contains('black',c)
                            d=[0,0,0];
                        else
                            d=[0,0,1];
                        end
                    end
                case 'c',d=[0,1,1];
                case 'm',d=[1,0,1];
                case 'y',d=[1,1,0];
                case 'k',d=[0,0,0];
                otherwise
                    error('Unrecognized color');
                end
            elseif isnumeric(c)&&ismatrix(c)
                d=c;
            else
                error('Not a valid colorspec.');
            end
        end

        function crgb=getComplementaryColor(rgb)
            crgb=1-rgb;
        end
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
        function lch=rgb2lch(rgb,varargin)













            lch=internal.ColorConversion.lab2lch(rgb2lab(rgb,varargin{:}));
        end
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
        function lch=lab2lch(lab)









            CIE_L=lab(:,1);
            CIE_a=lab(:,2);
            CIE_b=lab(:,3);
            CIE_H=atan2(CIE_b,CIE_a);
            if CIE_H>0
                CIE_H=CIE_H*180/pi;
            else
                CIE_H=360-abs(CIE_H)*180/pi;
            end
            CIE_C=hypot(CIE_a,CIE_b);
            lch=[CIE_L,CIE_C,CIE_H];
        end

        function lab=lch2lab(lch)









            CIE_L=lch(:,1);
            CIE_C=lch(:,2);
            CIE_Hr=lch(:,3)*pi/180;
            CIE_a=CIE_C.*cos(CIE_Hr);
            CIE_b=CIE_C.*sin(CIE_Hr);
            lab=[CIE_L,CIE_a,CIE_b];
        end

        function rgb=glowColor(rgb,frac)












            if nargin<2
                frac=0.85;
            end
            if all(rgb>0.9)


                rgb=rgb*0.7;
            else
                rgb=[1,1,1]*frac+rgb*(1-frac);
            end
        end

        function[rgbo,anyChange]=brighten(rgb,frac)




            if frac==0

                rgbo=rgb;
                anyChange=false;
            else
                rgb=internal.ColorConversion.getRGBFromColor(rgb);
                if frac>0

                    rgbo=rgb*(1-frac)+[1,1,1]*frac;
                elseif frac<0




                    rgbo=rgb*(1+frac);
                end


                anyChange=~isequal(rgb,rgbo);
            end
        end
    end



    methods(Static)
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
        function ret=RadialStem(Nstems,cmap,Rcircle,Rstem)






















            if nargin<1
                Nstems=12;
            end
            if nargin<2
                cmap=jet(Nstems);
            end
            if nargin<4
                Rstem=1.0;
            end
            if nargin<3
                if Nstems<2
                    Rcircle=1.0;
                else
                    Rcircle=Rstem*sin(pi/Nstems);
                end
            end





            fig=gcf;
            Rt=Rstem+Rcircle;
            ax=gca;
            set(ax,...
            'Parent',fig,...
            'Visible','off',...
            'XLim',[-Rt,Rt],...
            'YLim',[-Rt,Rt]);
            axis(ax,'equal');




            c=internal.ColorConversion.getRGBFromColor(cmap);
            Ncolors=size(c,1);
            if Ncolors>Nstems

                c=c(1:Nstems,:);
            elseif Ncolors<Nstems&&Ncolors>1

                repi=floor(Nstems/Ncolors);
                repf=rem(Nstems,Ncolors);
                c=[repmat(c,repi,1);c(1:repf,:)];
            end


            if Nstems<2
                pts=[0,0];
            else
                pts=internal.ColorConversion.PointsOnCircle(Nstems,[0,0],Rstem);
            end



            if Nstems<2
                hl=[];
            else
                x=zeros(3,Nstems);
                y=zeros(3,Nstems);
                x(2,:)=pts(:,1)';
                x(3,:)=NaN;
                y(2,:)=pts(:,2)';
                y(3,:)=NaN;
                hl=line(...
                'Parent',ax,...
                'LineWidth',1,...
                'Clipping','off',...
                'XData',x(:),...
                'YData',y(:));
            end


            NPtsPerCircle=45;
            hc=internal.ColorConversion.FilledCircles(ax,pts,Rcircle,NPtsPerCircle);
            hc.FaceColor='flat';
            hc.EdgeColor='k';
            hc.FaceVertexCData=c;


            if nargout>0
                ret.Circles=hc;
                ret.Lines=hl;
            end
        end
    end


    methods(Static)
        function[ret,th]=PointsOnCircle(N,C,R)
















            if nargin<3
                R=1;
                if nargin<2
                    C=[0,0];
                    if nargin<1
                        N=180;
                    end
                end
            end

            validateattributes(N,{'numeric'},...
            {'nonnegative','real','integer','scalar'},'','NPoints',1);
            validateattributes(C,{'numeric'},...
            {'vector','real','row'},'','Center',2);
            Nc=numel(C);
            if Nc<2||Nc>3
                error('Center C must be a 2- or 3-element vector');
            end
            validateattributes(R,{'numeric'},...
            {'nonnegative','real','scalar'},'','NPoints',3);

            if N==0
                ret=zeros(0,Nc);
                th=zeros(0,1);
            else




                th=pi/2-2*pi*(0:N-1)'/N;
                if Nc==2
                    ret=bsxfun(@plus,[cos(th)*R,sin(th)*R],C);
                else
                    ret=bsxfun(@plus,[cos(th)*R,sin(th)*R,zeros(size(th))],C);
                end
            end
        end

        function h=FilledCircles(ax,ctr,R,Npts)




















            Nargs=nargin;
            if Nargs<4
                if Nargs>0
                    if~ishghandle(ax)
                        if Nargs>2
                            Npts=R;
                        end
                        if Nargs>1
                            R=ctr;
                        end
                        if Nargs>0
                            ctr=ax;
                        end
                        ax=gca;
                    end
                else
                    ax=gca;
                end
            end




            if Nargs<4
                Npts=360;
            end
            validateattributes(Npts,{'numeric'},...
            {'positive','integer','scalar'},'','NPoints',4);


            if Nargs<3
                R=1;
            end
            NR=numel(R);
            if NR>1&&NR~=Nctrs
                error('R must be a scalar, or a vector with number of elements the same as number of rows in C');
            end
            if NR==1
                Rinc=0;
            else
                Rinc=1;
            end


            if Nargs<2
                ctr=[0,0];
            end
            [Nctrs,Nc]=size(ctr);
            if~ismatrix(ctr)||Nc<2||Nc>3
                error('Center must be an Nx2 or Nx3 matrix.');
            end





            th=pi/2-2*pi*(0:Npts-1)'/Npts;
            x=cos(th);
            y=sin(th);



            f=reshape(1:Npts*Nctrs,Npts,Nctrs)';
            v=zeros(Npts*Nctrs,Nc);
            Ridx=1;
            for i=1:Nctrs

                r_i=R(Ridx);
                Ridx=Ridx+Rinc;

                i1=(i-1)*Npts+1;
                i2=i*Npts;
                if Nc==2
                    v(i1:i2,:)=bsxfun(@plus,[x*r_i,y*r_i],ctr(i,:));
                else
                    v(i1:i2,:)=bsxfun(@plus,[x*r_i,y*r_i,zeros(size(x))],ctr(i,:));
                end
            end

            h=patch(...
            'Parent',ax,...
            'Clipping','off',...
            'Vertices',v,...
            'Faces',f);
        end
    end
end
