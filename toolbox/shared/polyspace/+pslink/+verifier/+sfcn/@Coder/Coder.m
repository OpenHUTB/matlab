classdef Coder<pslink.verifier.Coder

    properties(Constant,GetAccess=public)
        CODER_NAME='S-Function';
        CODER_ID='sfcn';
        CODER_VERIF_NAME='SFUNCTION';
        CODER_IDE_NAME='SFUNCTION';
        BUILT_IN_TYPES={'double','single','boolean','int8',...
        'int16','int32','uint8','uint16','uint32'};
    end


    properties(Constant,GetAccess=private)
        PRODUCT_NAME='Polyspace';
    end


    properties
SFunctionInfo
SFunctionName
        PatchedFiles=[]
GeneratedWrapperInfo
ExtraLinksDataSources
    end


    methods(Static=true)

        function str=getCoderName()
            str=pslink.verifier.sfcn.Coder.CODER_NAME;
        end
    end


    methods

        function self=Coder(sfcnPath,pslinkOptions)
            if nargin<2
                pslinkOptions=pslink.Options(sfcnPath);
            end
            self@pslink.verifier.Coder(sfcnPath);
            self.SFunctionName=get_param(sfcnPath,'FunctionName');
            self.sysDirInfo=pslink.util.Helper.getConfigDirInfo(self.slSystemName,pslink.verifier.sfcn.Coder.CODER_ID);
            resultDir=pslinkOptions.ResultDir;
            self.cgName=fullfile(resultDir,'pslink');
            self.cgDirStatus=exist(self.sysDirInfo.SystemCodeGenDir,'dir');

            self.inputFullRange=true;
            self.ExtraLinksDataSources={};
        end


        function extractAllInfo(self,opts)
            sfcnPath=self.slSystemName;
            sfcnName=self.SFunctionName;

            tmpDir=self.cgName;

            [~,~,~]=mkdir(tmpDir);

            reader=sldv.code.sfcn.internal.StaticSFcnInfoReader(sfcnName,tmpDir);
            self.SFunctionInfo=reader.getSFunctionInfo(false);
            self.checkCompiler();

            db=reader.getDb();
            [sourcePaths,includeDirs]=self.getSources(db,sfcnName);
           cxxfe=internal.cxxfe.util.getMexFrontEndOptions('lang',self.SFunctionInfo.Language);
            defines=self.SFunctionInfo.FrontEndOptions.Defines;

            varPrefix='_';
            fcnPrefix='_';
            wrappersDir='';
            origAnalyzedFiles=sourcePaths;
            if~isempty(self.SFunctionInfo.SimStructs)
                wrappersDir=self.generateSimStructHeaders(tmpDir);

                if~isfield(self.SFunctionInfo.Functions,'Start')
                    mdlStartIndexes=strcmp(defines,'MDL_START');
                    defines=defines(~mdlStartIndexes);
                end
            end

            if isempty(sourcePaths)
                error('pslink:noSFcnSources',message('polyspace:gui:pslink:noSFcnSources',sfcnName).getString());
            end

            sysIncludes=cxxfe.Preprocessor.SystemIncludeDirs;

            if~isempty(wrappersDir)
                self.fileInfo.include=[wrappersDir;sysIncludes(:);includeDirs(:)];
            else
                self.fileInfo.include=[sysIncludes(:);includeDirs(:)];
            end
            self.fileInfo.source=sourcePaths;
            self.fileInfo.define=defines;
            if~isempty(self.SFunctionInfo.FrontEndOptions.UnDefines)
                self.fileInfo.undefine=self.SFunctionInfo.FrontEndOptions.UnDefines;
            end



            useCalibrationValues=strcmp(opts.ParamRangeMode,'None');
            [allInstances,warningMessages]=sldv.code.sfcn.internal.getSFcnInfoFromModel(self.slModelName,...
            sfcnName,useCalibrationValues,pslink.verifier.sfcn.Coder.PRODUCT_NAME);
            if opts.VerifAllSFcnInstances
                instances=allInstances;
            else
                instances=allInstances.keepInstance(sfcnPath);
                blockHandle=get_param(sfcnPath,'Handle');
                if~isempty(warningMessages)
                    warningMessages=warningMessages(warningMessages.Handle==blockHandle);
                end
            end

            if isempty(instances)
                warningDetails='';
                if~isempty(warningMessages)

                    warningDetails=strjoin({warningMessages.Message},'\n');
                end
                error('pslink:noSFcnToAnalyze',message('polyspace:gui:pslink:noSFcnToAnalyze',warningDetails).getString());
            else
                for ww=1:numel(warningMessages)
                    warning(warningMessages(ww).Id,warningMessages(ww).Message);
                end
            end

            mainFileHeader=sprintf(['/* Copyright %s The MathWorks, Inc.\n',...
            ' *\n',...
            ' * THIS FILE IS AUTOMATICALLY GENERATED AND USED BY POLYSPACE.\n',...
            ' * DO NOT MODIFY IT.\n',...
            ' */\n'],datestr(now,'yyyy'));
            sfcnMainFile=self.SFunctionInfo.MainFile;
            mainFileIndex=strcmp(sourcePaths,sfcnMainFile);
            sfcnMainFile=fullfile(tmpDir,'simulink.c');
            if~any(mainFileIndex)
                additionalMain=true;
                db.extractSFunctionMain(sfcnMainFile,mainFileHeader);
            else
                additionalMain=false;
                slDir=wrappersDir;


                sfcnMainFile=fullfile(slDir,'simulink.c');

                fid=fopen(sfcnMainFile,'w','n',self.SourceEncoding);
                fprintf(fid,'%s\n',mainFileHeader);
                fclose(fid);






                self.ExtraLinksDataSources={sfcnMainFile};
            end

            instanceInfos=instances.getInstanceInfos(sfcnName);

            options=struct();
            options.MainFile=sfcnMainFile;
            options.GeneratePsInputs=false;
            options.VarPrefix=varPrefix;
            options.FcnPrefix=fcnPrefix;
            options.GenerateCodeInformation=true;
            options.GenerateAsserts=true;
            options.FunctionWrappers=true;
            options.ModelName=self.slModelName;
            [sfunctionWrappers,preIncludeFile,simStructStubs]=sldv.code.sfcn.internal.generateSfcnWrappers(...
            sfcnName,self.SFunctionInfo,instanceInfos,options);

            if~isempty(preIncludeFile)
                self.fileInfo.extra_headers={preIncludeFile};
            end

            mainFileOptions=struct();
            mainFileOptions.VarRadix=sprintf('__%s',sfcnName);
            mainFileOptions.FcnRadix=sprintf('__%s',sfcnName);
            mainFileOptions.CoderFunctions=true;
            mainFileOptions.AppendToFile=sfcnMainFile;

            self.getDesignMinMax(opts,instanceInfos,sfunctionWrappers);

            [~,fcnInfo]=sldv.code.sfcn.internal.generatePseudoMain(sfunctionWrappers,...
            self.SFunctionInfo.Language,...
            tmpDir,...
            mainFileOptions);

            if additionalMain
                self.fileInfo.source{end+1}=sfcnMainFile;
                origAnalyzedFiles{end+1}=sfcnMainFile;
            end

            self.fcnInfo.codeLanguage=self.SFunctionInfo.Language;

            if~isempty(fcnInfo.InitFcn)
                self.fcnInfo.init=pslink.verifier.Coder.createFcnInfoStruct();
                self.fcnInfo.init.fcn={fcnInfo.InitFcn};
            end

            self.fcnInfo.step=pslink.verifier.Coder.createFcnInfoStruct();
            self.fcnInfo.step.fcn={fcnInfo.StepFcn};
            self.fcnInfo.step.var=vertcat(sfunctionWrappers.InputVars);

            if~isempty(fcnInfo.TermFcn)
                self.fcnInfo.term=pslink.verifier.Coder.createFcnInfoStruct();
                self.fcnInfo.term.fcn={fcnInfo.TermFcn};
            end



            self.GeneratedWrapperInfo=struct();
            self.GeneratedWrapperInfo.SFunction=sfunctionWrappers;
            self.GeneratedWrapperInfo.MainFile=options.MainFile;
            self.GeneratedWrapperInfo.AnalyzedFileMap=containers.Map(self.fileInfo.source,origAnalyzedFiles);
            self.GeneratedWrapperInfo.SimStructStubs=simStructStubs;


            self.dlinkInfo.name=self.slModelName;
            self.dlinkInfo.source='traceInfo';
            self.dlinkInfo.model=self.slModelFileName;
            self.dlinkInfo.version=self.slModelVersion;
            self.dlinkInfo.info(1:numel(instanceInfos))=pslink.verifier.Coder.createLinkDataInfoStruct();
            for ii=1:numel(instanceInfos)
                fullName=Simulink.ID.getFullName(instanceInfos(ii).SID);
                pathStart=strfind(fullName,'/');
                if isempty(pathStart)
                    pathStart=1;
                end

                self.dlinkInfo.info(ii).name=fullName;
                self.dlinkInfo.info(ii).codename=['<Root>',fullName(pathStart:end)];
                self.dlinkInfo.info(ii).path=fullName;
                self.dlinkInfo.info(ii).sid=instanceInfos(ii).SID;
            end

        end


        function checkSum=getCheckSum(self)%#ok<MANU>
            checkSum=[];
        end







        function language=getLanguage(self)
            language=self.SFunctionInfo.Language;
        end







        function dialect=getDialect(self)
            dialect=self.SFunctionInfo.Dialect;
        end



        function targetInfo=getTargetInfo(self)
            fcnInfo=self.SFunctionInfo.FrontEndOptions;
            if strcmp(fcnInfo.Endianness,'little')
                endianess='LittleEndian';
            else
                endianess='BigEndian';
            end
            targetInfo=struct('CharNumBits',fcnInfo.CharNumBits,...
            'IsCharSigned',fcnInfo.PlainCharsAreSigned,...
            'ShortNumBits',fcnInfo.ShortNumBits,...
            'IntNumBits',fcnInfo.IntNumBits,...
            'LongNumBits',fcnInfo.LongNumBits,...
            'LongLongNumBits',fcnInfo.LongLongNumBits,...
            'FloatNumBits',fcnInfo.FloatNumBits,...
            'DoubleNumBits',fcnInfo.DoubleNumBits,...
            'LongDoubleNumBits',fcnInfo.LongDoubleNumBits,...
            'PointerNumBits',fcnInfo.PointerNumBits,...
            'WordNumBits',fcnInfo.IntNumBits,...
            'Endianess',endianess,...
            'ShiftRightIntArith',1,...
            'HWDeviceType','Generic->MATLAB Host Computer');
        end
    end

    methods(Access=private)



        function wrappersDir=generateSimStructHeaders(~,tmpDir)

            wrappersDir=fullfile(tmpDir,'include_wrappers');
            [success,errorMessage,~]=mkdir(wrappersDir);

            if success
                sldv.code.sfcn.internal.HandwrittenFEHandler.generateWrapperHeaders(wrappersDir);
            else
                eror('pslink:cannotCreateDir',message('polyspace:gui:pslink:cannotCreateDir',includeDir,errorMessage).getString());
            end
        end




        function getDesignMinMax(self,pslinkOptions,instances,wrappers)


            if strcmpi(pslinkOptions.InputRangeMode,'DesignMinMax')
                self.inputFullRange=false;
            end

            sess=Simulink.CMI.EIAdapter(Simulink.EngineInterfaceVal.byFiat);%#ok<NASGU>
            needTermination=false;

            warnStruct=warning;
            restoreWarnings=onCleanup(@()warning(warnStruct));

            rethrowEx=[];
            try
                warning('off');
                if~strcmpi(get_param(self.slModelName,'SimulationStatus'),'initializing')

                    evalc('feval(self.slModelName, [],[], [], ''compile'')');
                    needTermination=true;
                end

                drsHelper=pslink.util.DrsInfoHelper(self.slModelName,self.inputFullRange);

                for ii=1:numel(wrappers)
                    currentInstance=instances(ii);
                    currentWrapper=wrappers(ii);
                    sid=currentInstance.SID;


                    if strcmp(pslinkOptions.ParamRangeMode,'DesignMinMax')
                        paramsString=get_param(sid,'Parameters');
                        paramNames=strsplit(paramsString,{' ',','});
                        if numel(currentInstance.DialogParameterInfo)==numel(paramNames)



                            treatRtParamsAsDlgParams=isempty(self.SFunctionInfo.SimStructs)&&...
                            (numel(currentWrapper.DialogParameterVars)==numel(currentWrapper.ParameterVars));

                            for p=1:numel(currentInstance.DialogParameterInfo)
                                paramNames{p}=pslink.verifier.sfcn.Coder.getParameterName(paramNames{p});
                                [slObj,~]=slResolve(paramNames{p},sid,'variable','startUnderMask');
                                if treatRtParamsAsDlgParams
                                    varName=currentWrapper.ParameterVars{p};
                                    varType=currentInstance.ParameterPortInfo(p).Type;
                                else
                                    varName=currentWrapper.DialogParameterVars{p};
                                    varType=currentInstance.DialogParameterInfo(p).Type;
                                end
                                drsHelper.extractDrs('param',varName,varType,slObj,sid);
                            end
                        end
                    end

                    sfcnObj=get_param(sid,'Object');
                    ports=sfcnObj.PortHandles;


                    for inp=1:numel(currentWrapper.InputVars)
                        currentVar=currentWrapper.InputVars{inp};
                        currentInput=ports.Inport(inp);
                        varType=currentInstance.InputPortInfo(inp).Type;

                        drsHelper.addDrsInput(currentInput,currentVar,varType);
                    end



                    if strcmp(pslinkOptions.OutputRangeMode,'DesignMinMax')
                        for o=1:numel(currentWrapper.OutputVars)
                            currentVar=currentWrapper.OutputVars{o};
                            currentOutput=ports.Outport(o);
                            varType=currentInstance.OutputPortInfo(o).Type;

                            drsHelper.addDrsOutput(currentOutput,currentVar,varType);
                        end
                    end
                end

                self.drsInfo=drsHelper.getDrsInfo();
            catch Me
                rethrowEx=Me;
            end

            if needTermination
                evalc('feval(self.slModelName, [],[], [], ''term'')');
            end

            if~isempty(rethrowEx)
                warning('pslink:unexpectedErrorForRangeGeneration',message('polyspace:gui:pslink:unexpectedErrorForRangeGeneration',rethrowEx.message).getString());
            end
        end


        function ok=checkFiles(~,files)
            ok=true;
            for ii=1:numel(files)
                d=dir(files{ii});
                if isempty(d)||d.isdir
                    ok=false;
                    return
                end
            end
        end


        function ok=checkSources(self,sources,headers)
            ok=self.checkFiles(sources)&&self.checkFiles(headers);
        end




        function[sources,includes]=getSources(self,db,sfcnName)
            mrootSymb=db.getSymbolicName('MATLAB_ROOT');
            anchorSymb=db.getSymbolicName('ANCHOR_DIR');

            includes=self.SFunctionInfo.FrontEndOptions.IncludeDirs;
            if~isempty(anchorSymb)
                for ii=1:numel(includes)
                    includes{ii}=polyspace.internal.getAbsolutePath(includes{ii},anchorSymb.value);
                end




                includes{end+1}=anchorSymb.value;
            end

            sourceFiles=db.getSourceFiles();
            sources={sourceFiles.path};

            headerFiles=db.getHeaderFiles();
            headerPaths={headerFiles.path};

            preIncludes=db.getAllPreIncludes();




            preIncludeIndexes=false(size(headerPaths));
            for ii=1:numel(preIncludes)
                currentHeader=preIncludes{ii};
                preIncludeIndexes=preIncludeIndexes|strcmp(currentHeader,headerPaths);
            end
            headerPaths(preIncludeIndexes)=[];
            headerFiles(preIncludeIndexes)=[];


            userIncludeIndexes=true(size(includes));
            if~isempty(mrootSymb)
                mrootComp=mrootSymb.value;


                for ii=1:numel(includes)
                    currentInclude=includes{ii};
                    isMatlabHeader=polyspace.internal.isInSubDirectory(mrootComp,currentInclude);
                    userIncludeIndexes(ii)=~isMatlabHeader;
                    if isMatlabHeader
                        currentInclude=currentInclude(numel(mrootComp)+1:end);

                        includes{ii}=fullfile(matlabroot,currentInclude);
                    end
                end


                userHeaderIndexes=false(size(headerPaths));
                for ii=1:numel(headerPaths)
                    currentHeader=headerPaths{ii};
                    userHeaderIndexes(ii)=~polyspace.internal.isInSubDirectory(mrootComp,currentHeader);
                end
                headerPaths(~userHeaderIndexes)=[];
                headerFiles(~userHeaderIndexes)=[];
            end


            if~self.checkSources(sources,headerPaths)
                mexPath=which(sfcnName);
                modelPath=which(self.slModelName);

                mexDir=fileparts(mexPath);
                modelDir=fileparts(modelPath);



                prefixes=unique({mexDir;modelDir;pwd},'stable');

                for ii=1:numel(prefixes)
                    prefix=prefixes{ii};
                    [sourcesPrefix,matchingSourcesRoot]=polyspace.internal.recognizeTreeStructure(sources,prefix);
                    [headersPrefix,matchingHeaderPrefix]=polyspace.internal.recognizeTreeStructure(headerPaths,prefix);

                    if~isempty(matchingSourcesRoot)&&~isempty(matchingHeaderPrefix)
                        sources=pslink.verifier.sfcn.Coder.replacePrefix(sources,sourcesPrefix,matchingSourcesRoot{1});
                        headerPaths=pslink.verifier.sfcn.Coder.replacePrefix(headerPaths,headersPrefix,matchingHeaderPrefix{1});

                        includes=pslink.verifier.sfcn.Coder.replacePrefix(includes,headersPrefix,matchingHeaderPrefix{1});

                        pslink.verifier.sfcn.Coder.checkSFunctionSources(sources,sourceFiles,...
                        headerPaths,headerFiles,sfcnName);

                        includes=pslink.verifier.sfcn.Coder.keepExisting(includes);
                        return
                    end
                end


                sources={};
                includes={};
            end

            pslink.verifier.sfcn.Coder.checkSFunctionSources(sources,sourceFiles,...
            headerPaths,headerFiles,sfcnName);

            includes=pslink.verifier.sfcn.Coder.keepExisting(includes);
        end








        function checkCompiler(self)
            feOpts=internal.cxxfe.util.getMexFrontEndOptions('lang',self.SFunctionInfo.Language);
            compilerInfo=sldv.code.internal.getCompilerInfo(feOpts);

            if~strcmp(self.SFunctionInfo.Compiler,compilerInfo.compiler)||...
                compilerInfo.compilerVersion~=self.SFunctionInfo.CompilerVersion
                warning('pslink:sfcnCompMismatch',message('polyspace:gui:pslink:sfcnCompMismatch').getString());
            end
        end
    end

    methods(Access=private,Static=true)




        function checkSFunctionSources(sources,sourceFiles,...
            headers,headerFiles,...
            sfcnName)
            if~pslink.verifier.sfcn.Coder.checkModificationDates(sources,sourceFiles)||...
                ~pslink.verifier.sfcn.Coder.checkModificationDates(headers,headerFiles)
                warning('pslink:sfcnOutOfDate',message('polyspace:gui:pslink:sfcnOutOfDate',sfcnName).getString());
            end
        end





        function ok=checkModificationDates(sources,sourceFiles)
            ok=true;
            if numel(sources)==numel(sourceFiles)
                for ii=1:numel(sources)
                    src=sources{ii};
                    d=dir(src);
                    if~isempty(d)&&~d.isdir




                        compTime=datetime(sourceFiles(ii).lastModifiedTime,'InputFormat','yyyy-MM-dd HH:mm:ss');
                        compTime.TimeZone='UTC';

                        fileTimeString=datestr(d.datenum,'yyyy-mm-dd HH:MM:SS');
                        fileTime=datetime(fileTimeString,'InputFormat','yyyy-MM-dd HH:mm:ss');
                        fileTime.TimeZone='local';

                        if posixtime(fileTime)>posixtime(compTime)
                            ok=false;
                            return
                        end
                    end
                end
            end
        end





        function commonPrefix=computePrefix(sources,currentPrefix)
            commonPrefix=currentPrefix;

            for ii=1:numel(sources)
                currentPath=sources{ii};

                while~polyspace.internal.isInSubDirectory(commonPrefix,currentPath)
                    [commonPrefix,prev,ext]=fileparts(commonPrefix);
                    if isempty(prev)&&isempty(ext)
                        commonPrefix='';
                        return
                    end
                end
            end
        end




        function result=removePrefix(paths,prefix)
            prefixCount=numel(prefix);
            result=paths;

            if prefixCount>0
                for ii=1:numel(paths)
                    currentPath=paths{ii};
                    currentPath=currentPath(prefixCount+1:end);
                    result{ii}=currentPath;
                end
            end
        end



        function result=replacePrefix(paths,oldPrefix,newPrefix)
            prefixRemoved=pslink.verifier.sfcn.Coder.removePrefix(paths,oldPrefix);
            result=fullfile(newPrefix,prefixRemoved);
        end




        function paramName=getParameterName(paramName)
            for ii=1:numel(pslink.verifier.sfcn.Coder.BUILT_IN_TYPES)
                if(strncmpi(paramName,pslink.verifier.sfcn.Coder.BUILT_IN_TYPES{ii},length(pslink.verifier.sfcn.Coder.BUILT_IN_TYPES{ii})))
                    pattern=['\s*',pslink.verifier.sfcn.Coder.BUILT_IN_TYPES{ii},'\s*\((\w+)\)'];
                    paramName=regexp(paramName,pattern,'tokens');
                    if~isempty(paramName)
                        paramName=paramName{1}{1};
                        break
                    end
                end
            end
        end





        function remaining=keepExisting(original)
            existing=true(size(original));

            for ii=1:numel(original)
                existing(ii)=~isempty(dir(original{ii}));
            end

            remaining=original(existing);
        end
    end
end




