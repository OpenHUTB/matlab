




classdef TargetApplicationServiceBuilder<matlab.mixin.SetGet
    properties
OutputFile
BuildDir
Toolchain
TargetRoot
IOInterfaceName
TargetServicesSrcDir
TargetServiceMakefile
    end
    properties(Dependent)
TargetHardware
    end
    properties(SetAccess='private',GetAccess='private')
Buffer
ToolchainInfo
AttributeInfo
    end
    methods
        function h=TargetApplicationServiceBuilder(fileName,toolchain,targetServiceMakefile,targetHardwareName,targetServicesSrcDir)
            validateattributes(fileName,{'char'},{'nonempty'});
            validateattributes(toolchain,{'char','coder.make.ToolchainInfo','coder.make.internal.adapter.IToolchain'},{'nonempty'});
            validateattributes(targetServiceMakefile,{'char'},{'nonempty'});
            assert(isequal(exist(targetServiceMakefile,'file'),2),'the specified Target Service/App Service Makefile does not exist');
            h.OutputFile=fileName;
            h.BuildDir=fileparts(fileName);
            if nargin<5
                h.TargetServicesSrcDir=h.BuildDir;
            else
                h.TargetServicesSrcDir=targetServicesSrcDir;
            end
            if coder.make.internal.isToolchainObject(toolchain)
                h.ToolchainInfo=toolchain;
                h.Toolchain=toolchain.Name;
            elseif isequal(toolchain,coder.make.internal.getInfo('default-toolchain'))
                h.ToolchainInfo=coder.make.internal.getToolchainInfoFromRegistry(coder.make.getDefaultToolchain);
                h.Toolchain=toolchain;
            else
                h.ToolchainInfo=coder.make.internal.getToolchainInfoFromRegistry(toolchain);
                h.Toolchain=toolchain;
            end
            h.TargetServiceMakefile=targetServiceMakefile;
            if nargin>3
                h.TargetHardware=targetHardwareName;
            end
        end
        function write(hObj)
            path2File=fileparts(hObj.OutputFile);
            if~isequal(exist(path2File,'dir'),7)
                mkdir(path2File);
            end
            lOutputFileID=fopen(hObj.OutputFile,'w+');
            hObj.writeBuffer;
            fwrite(lOutputFileID,hObj.Buffer);
            fclose(lOutputFileID);
        end
        function build(hObj)
            runMakefile(hObj,'build');
        end
        function clean(hObj)
            runMakefile(hObj,'clean');
        end
    end
    methods
        function set.TargetHardware(h,targetHardware)
            validateattributes(targetHardware,{'char','codertarget.targethardware.TargetHardwareInfo'},{'nonempty'});
            if ischar(targetHardware)
                targetHardwareNames=codertarget.targethardware.getRegisteredTargetHardwareNames();
                [found,~]=ismember(targetHardware,targetHardwareNames);
                assert(found,sprintf('Invalid target hardware name, select one among these:\n %s',coder.make.internal.cell2str(targetHardwareNames,char(10))));
                lHWInfo=codertarget.targethardware.getTargetHardware(targetHardware);
                h.TargetRoot=lHWInfo.TargetFolder;
                h.AttributeInfo=codertarget.attributes.getTargetHardwareAttributesForHardwareName(targetHardware);
            else
                lHWInfo=codertarget.targethardware.getTargetHardware(targetHardware.Name);
                h.TargetRoot=lHWInfo.TargetFolder;
                h.AttributeInfo=codertarget.attributes.getTargetHardwareAttributesForHardwareName(targetHardware.Name);
            end
            lIOInterfaceName=h.AttributeInfo.ExternalModeInfo.getIOInterfaceNames();
            h.IOInterfaceName=lIOInterfaceName{1};
        end
    end
    methods(Access='private')
        function writeBuffer(h)
            assert(~isempty(h.AttributeInfo),'Invalid target');
            assert(~isempty(h.IOInterfaceName),'Invalid I/O Interface');
            assert(~isempty(h.Toolchain),'Invalid Toolchain');
            maketool=h.ToolchainInfo.BuilderApplication;
            h.Buffer=['#',10,'# Automatically generated by codertarget.targetservices.TargetApplicationServiceBuilder',10];

            h.addLine('# Target Service Macros');
            buildDir=coder.make.internal.transformPaths(h.BuildDir,'ignoreErrors',true,'pathType','alternate','mapUNCPaths',h.ToolchainInfo.isAttribute('SupportsUNCPaths'));
            h.addLine(['OUTPUT_DIR = ',h.replaceFileSep(buildDir)]);
            targetServicesSrcDir=coder.make.internal.transformPaths(h.TargetServicesSrcDir,'ignoreErrors',true,'pathType','alternate','mapUNCPaths',h.ToolchainInfo.isAttribute('SupportsUNCPaths'));
            h.addLine(['TARGET_SERVICES_SRC_DIR = ',h.replaceFileSep(targetServicesSrcDir)]);
            h.addLine([10,'# Toolchain Macros']);
            macrokeys=h.ToolchainInfo.Macros.keys;
            for ii=1:h.ToolchainInfo.Macros.length
                if~isempty(h.ToolchainInfo.Macros.getValue(ii))
                    tcMacro=coder.make.internal.transformPaths(h.ToolchainInfo.Macros.getValue(ii),'ignoreErrors',true,'pathType','alternate','mapUNCPaths',h.ToolchainInfo.isAttribute('SupportsUNCPaths'));
                    h.addLine([macrokeys{ii},' = ',h.replaceFileSep(tcMacro)]);
                else
                    h.addLine(['# ',macrokeys{ii},' = Intrinsically defined']);
                end
            end
            tgtSvcObj=h.AttributeInfo.getTargetService('toolchain',h.Toolchain,'iointerfacename',h.IOInterfaceName);
            assert(~isempty(tgtSvcObj),'Target Services not supported for this Toolchain and I/O Interface combination');
            if isequal(h.ToolchainInfo.BuildArtifact,'nmake makefile')
                assignOperator=' = ';
            else
                assignOperator=' := ';
            end
            h.addLine(['TARGET_SVC_CPP_FLAGS = ',tgtSvcObj.BuildConfigurationInfo.CompileFlags]);
            h.addLine(['TARGET_SVC_LD_FLAGS = ',tgtSvcObj.BuildConfigurationInfo.LinkFlags]);
            if~isempty(tgtSvcObj.MaxPoolSize)
                h.addLine(['TGTSVC_MAX_POOL_SIZE = ',num2str(tgtSvcObj.MaxPoolSize)]);
            end
            h.addLine([10,'# Target Macros']);
            tokens=h.AttributeInfo.getTokens;
            for ii=1:numel(tokens)
                tokenName=tokens{ii}.Name;
                tokenValue=tokens{ii}.Value;
                if~isempty(tokenValue)
                    str=which(tokenValue);
                    [~,~,e]=fileparts(str);
                    if isequal(e,'.m')||isequal(e,'.p')
                        try
                            tokenValue=eval(tokenValue);
                        catch
                            tokenValue='';
                        end
                    end
                end
                if isempty(tokenValue)
                    tokenValue=getenv(tokenName);
                end
                tokenValue=coder.make.internal.transformPaths(tokenValue,'ignoreErrors',true,'pathType','alternate','mapUNCPaths',h.ToolchainInfo.isAttribute('SupportsUNCPaths'));
                h.addLine([tokenName,' = ',h.replaceFileSep(tokenValue)]);
            end

            targetRoot=coder.make.internal.transformPaths(h.TargetRoot,'ignoreErrors',true,'pathType','alternate','mapUNCPaths',h.ToolchainInfo.isAttribute('SupportsUNCPaths'));
            h.addLine(['TARGET_ROOT = ',h.replaceFileSep(targetRoot)])
            includePaths=coder.make.internal.transformPaths(h.AttributeInfo.BuildConfigurationInfo(1).IncludePaths,'ignoreErrors',true,'pathType','alternate','mapUNCPaths',h.ToolchainInfo.isAttribute('SupportsUNCPaths'));
            if isequal(h.ToolchainInfo.BuildArtifact,'nmake makefile')
                includePathSep=';';
            else
                includePathSep=[' \',10];
            end
            h.addLine(['INCLUDE_PATHS = ',coder.make.internal.cell2str(h.replaceFileSep(includePaths),includePathSep)]);

            ccbuildTool=h.ToolchainInfo.getBuildTool('C++ Compiler');
            h.addLine([10,'# ',ccbuildTool.getName]);
            if isempty(ccbuildTool.Path.getValue)
                h.addLine(['CPP',assignOperator,ccbuildTool.Command.getValue,10]);
            else
                h.addLine(['CPP_PATH',assignOperator,ccbuildTool.Path.getValue]);
                h.addLine(['CPP',assignOperator,'$(CPP_PATH)',maketool.getDirective('FileSeparator'),ccbuildTool.Command.getValue,10]);
            end

            ldbuildTool=h.ToolchainInfo.getBuildTool('C++ Linker');
            h.addLine(['# ',ldbuildTool.getName]);
            if isempty(ldbuildTool.Path.getValue)
                h.addLine(['CPP_LD',assignOperator,ldbuildTool.Command.getValue,10]);
            else
                h.addLine(['CPP_LD_PATH = ',ldbuildTool.Path.getValue]);
                h.addLine(['CPP_LD',assignOperator,'$(CPP_LD_PATH)',maketool.getDirective('FileSeparator'),ldbuildTool.Command.getValue,10]);
            end

            arbuildTool=h.ToolchainInfo.getBuildTool('Archiver');
            h.addLine(['# ',arbuildTool.getName]);
            if isempty(arbuildTool.Path.getValue)
                h.addLine(['AR = ',arbuildTool.Command.getValue,10]);
            else
                h.addLine(['AR_PATH',assignOperator,arbuildTool.Path.getValue]);
                h.addLine(['AR',assignOperator,'$(AR_PATH)',maketool.getDirective('FileSeparator'),arbuildTool.Command.getValue,10]);
            end

            h.addLine('# Directives and File Extensions');
            outext=ccbuildTool.getIOFileExtensions('Output');
            assert(numel(outext)==1,'The C++ Compiler must have an output file extension');
            h.addLine(['CPP_OBJECT_EXTENSION',assignOperator,outext{1},10]);
            h.addLine(['CPP_INCLUDE_DIRECTIVE',assignOperator,ccbuildTool.getDirective('IncludeSearchPath')]);
            h.addLine(['CPP_OUTPUT_DIRECTIVE',assignOperator,ccbuildTool.getDirective('OutputFlag')]);
            h.addLine(['CPP_LD_OUTPUT_DIRECTIVE',assignOperator,ldbuildTool.getDirective('OutputFlag')]);
            h.addLine(['AR_OUTPUT_DIRECTIVE',assignOperator,arbuildTool.getDirective('OutputFlag')]);
            h.addLine(['SHARED_LIB_EXTENSION',assignOperator,ldbuildTool.getFileExtension('Shared Library')]);
            h.addLine(['STATIC_LIB_EXTENSION',assignOperator,arbuildTool.getFileExtension('Static Library'),10]);

            bc=h.ToolchainInfo.getBuildConfiguration('Faster Runs');
            ccOption=bc.getOption('C++ Compiler');
            shldOption=bc.getOption('C++ Shared Library Linker');
            arOption=bc.getOption('Archiver');
            h.addLine([ccOption.getMacro,' = ',coder.make.internal.cell2str(ccOption.getValue)]);
            h.addLine([ccOption.getMacro,h.growOperator(ccOption.getMacro),'$(TARGET_SVC_CPP_FLAGS)']);
            h.addLine([ccOption.getMacro,h.growOperator(ccOption.getMacro),h.AttributeInfo.getCompileFlags,h.AttributeInfo.getCPPCompileFlags]);
            h.addLine([shldOption.getMacro,h.growOperator(shldOption.getMacro),coder.make.internal.cell2str(shldOption.getValue)]);
            h.addLine([shldOption.getMacro,h.growOperator(shldOption.getMacro),h.AttributeInfo.getLinkFlags,h.AttributeInfo.getCPPLinkFlags]);
            h.addLine([shldOption.getMacro,h.growOperator(shldOption.getMacro),'$(TARGET_SVC_LD_FLAGS)']);
            h.addLine([arOption.getMacro,' = ',coder.make.internal.cell2str(arOption.getValue),10]);

            h.addLine(['RM = ',maketool.getDirective('DeleteCommand')]);
            h.addLine(['ECHO = ',maketool.getDirective('DisplayCommand')]);
            lmlroot=coder.make.internal.transformPaths(matlabroot,'ignoreErrors',true,'pathType','alternate','mapUNCPaths',h.ToolchainInfo.isAttribute('SupportsUNCPaths'));
            h.addLine(['MATLAB_ROOT = ',regexprep(lmlroot,'[\\/]',maketool.getDirective('FileSeparator'))]);
            h.addLine('');
            h.addLine('# Inlined commands');
            h.addLine(coder.make.internal.cell2str(h.ToolchainInfo.InlinedCommands,sprintf('\n')));
            h.addLine('');
            h.addLine('# Build Using Target Services Rules');
            tgtsvcmkfile=coder.make.internal.transformPaths(h.TargetServiceMakefile,'ignoreErrors',true,'pathType','alternate','mapUNCPaths',h.ToolchainInfo.isAttribute('SupportsUNCPaths'));
            h.addLine([maketool.getDirective('IncludeFile'),32,h.replaceFileSep(tgtsvcmkfile)]);
        end
        function addLine(h,line)
            h.Buffer=[h.Buffer,10,line];
        end
        function out=replaceFileSep(h,inString)
            maketool=h.ToolchainInfo.BuilderApplication;
            out=regexprep(inString,'[\\/]',maketool.getDirective('FileSeparator'));
        end
        function out=growOperator(h,macro)
            if isequal(h.ToolchainInfo.BuildArtifact,'nmake makefile')
                out=[' = $(',macro,') '];
            else
                out=' += ';
            end
        end
        function runMakefile(hObj,cmd)
            validateattributes(cmd,{'char'},{});
            if~isequal(exist(hObj.OutputFile,'file'),2)
                hObj.write;
            end
            p=hObj.ToolchainInfo.ShellSetup;
            q=hObj.ToolchainInfo.ShellCleanup;
            if hObj.ToolchainInfo.isAttribute('RequiresBatchFile')&&(~isempty(p)||~isempty(q))
                [cdDir,filename,ext]=fileparts(hObj.OutputFile);
                currentDir=pwd;
                cd(cdDir);
                cleanupObj=onCleanup(@()cd(currentDir));
                fid=fopen('buildInBatch.bat','w+');
                r='';
                for ii=1:numel(p)
                    r=[r,10,p{ii}];%#ok<AGROW>
                end
                builder=hObj.ToolchainInfo.BuilderApplication;
                if~isempty(builder.Path.getValue)
                    pathStr=coder.make.internal.replaceMacrosInPath(...
                    builder.Name,builder.getPath(),hObj.ToolchainInfo);
                    command=fullfile(pathStr,builder.Command.getValue);
                else
                    command=builder.Command.getValue;
                end
                r=[r,10,command,' -f ',[filename,ext],' ',cmd];
                for ii=1:numel(q)
                    r=[r,10,q{ii}];%#ok<AGROW>
                end
                fwrite(fid,r);
                fclose(fid);
                system('buildInBatch.bat');
            else
                for ii=1:numel(p)
                    system(p{ii});
                end
                p=hObj.ToolchainInfo.MATLABSetup;
                for ii=1:numel(p)
                    eval(p{ii});
                end
                lPWD=pwd;
                cd(hObj.BuildDir);
                builder=hObj.ToolchainInfo.BuilderApplication;
                if~isempty(builder.Path.getValue)
                    pathStr=coder.make.internal.replaceMacrosInPath(...
                    builder.Name,builder.getPath(),hObj.ToolchainInfo);
                    command=fullfile(pathStr,builder.Command.getValue);
                else
                    command=builder.Command.getValue;
                end
                system([command,' -f ',hObj.OutputFile,' ',cmd]);
                cd(lPWD);
                p=hObj.ToolchainInfo.MATLABCleanup;
                for ii=1:numel(p)
                    eval(p{ii});
                end
                for ii=1:numel(q)
                    system(q{ii});
                end
            end
        end
    end
end
