function delayComp=getUnitDelayEnabledResettableComp(hN,hInSignals,hOutSignals,...
    hEnbSignals,hRstSignals,compName,ic,resettype,softreset,desc,slHandle)



    narginchk(9,11);

    if(nargin<11)
        slHandle=-1;
    end

    if(nargin<10)
        desc='';
    end

    if(isempty(ic))
        ic=pirelab.getTypeInfoAsFi(hInSignals.Type);
    else
        ic=pirelab.getTypeInfoAsFi(hInSignals.Type,'Floor','Wrap',ic);
    end

    if~isempty(resettype)
        resetnone=resettype;
    else
        resetnone=false;
    end

    hEnbSignals=pireml.getCompareToZero(hN,hEnbSignals(1),'~=',...
    sprintf('%s_enable',compName),sprintf('%s_not0',compName));
    hRstSignals=pireml.getCompareToZero(hN,hRstSignals(1),'~=',...
    sprintf('%s_enable',compName),sprintf('%s_not0',compName));

    [rstDims,~]=pirelab.getVectorTypeInfo(hRstSignals);
    [~,outType]=pirelab.getVectorTypeInfo(hOutSignals);

    if rstDims==1
        delayComp=createUDEComp(hN,hInSignals,hEnbSignals,hRstSignals,...
        hOutSignals,ic,resetnone,compName,desc,softreset,slHandle);
    else
        hDelayOutSignals=hdlhandles(rstDims,1);
        hDataDemux=pirelab.getDemuxCompOnInput(hN,hInSignals);
        hEnbDemux=pirelab.getDemuxCompOnInput(hN,hEnbSignals);%#ok<NASGU>
        hRstDemux=pirelab.getDemuxCompOnInput(hN,hRstSignals);%#ok<NASGU>
        for ii=1:rstDims
            hDelayOutSignals(ii)=hN.addSignal(outType,sprintf('%s_delay%d',compName,ii));
            delayComp=createUDEComp(hN,hDataDemux.PirOutputSignals(ii),...
            hEnbSignals.PirOutputSignals(ii),hRstSignals.PirOutputSignals(ii),...
            hDelayOutSignals(ii),ic(ii),resetnone,sprintf('%s_%d',compName,ii),...
            desc,softreset,slHandle);
        end
        hMux=pirelab.getMuxComp(hN,hDelayOutSignals,hOutSignals,...
        sprintf('%s_concat',compName));%#ok<NASGU>
    end
end

function delayComp=createUDEComp(hN,hInSignals,hEnbSignal,hRstSignal,...
    hOutSignals,ic,resetnone,compName,desc,softreset,slHandle)

    [clock,clkEnb,reset]=hN.getClockBundle(hInSignals(1),1,1,0);

    if softreset
        ipf='hdleml_delay';
        delayComp=hN.addComponent2(...
        'kind','cgireml',...
        'Name',compName,...
        'SimulinkHandle',slHandle,...
        'InputSignals',hInSignals,...
        'OutputSignals',hOutSignals,...
        'EnableSignals',clkEnb,...
        'ExternalEnableSignal',hEnbSignal,...
        'ExternalSynchronousResetSignal',hRstSignal,...
        'EMLFileName',ipf,...
        'EMLParams',{ic},...
        'EMLFlag_RunLoopUnrolling',false,...
        'EMLFlag_ConditionalStmtInProcess',true,...
        'BlockComment',desc);
    else
        ipf='hdleml_delay_resettable_classic';
        delayComp=hN.addComponent2(...
        'kind','cgireml',...
        'Name',compName,...
        'SimulinkHandle',slHandle,...
        'InputSignals',[hInSignals,hRstSignal],...
        'OutputSignals',hOutSignals,...
        'EnableSignals',clkEnb,...
        'ExternalEnableSignal',hEnbSignal,...
        'ExternalSynchronousResetSignal',hRstSignal,...
        'EMLFileName',ipf,...
        'EMLParams',{ic},...
        'EMLFlag_RunLoopUnrolling',false,...
        'BlockComment',desc);
    end

    delayComp.connectClockBundle(clock,clkEnb,reset);
    delayComp.resetNone(resetnone);
    delayComp.setIsSynchronousRegister(true);

    if targetmapping.isValidDataType(hInSignals(1).Type)
        delayComp.setSupportTargetCodGenWithoutMapping(true);
    end
end


