function varargout=upgrade(varargin)




































































































































    if nargout>0
        varargout{1}=[];
    end

    opts=defaultOptions;
    opts=parseArgs(opts,varargin{:});

    if opts.debug
        varargout{1}=opts;
    end

    if opts.parseOptionsOnly
        return;
    end

    if opts.doCleanupOnly
        doCleanup(opts);
        return;
    end


    opts=setupLogging(opts,opts.logDir,opts.logFile);


    files=getListOfFiles(opts);


    info.opts=opts;
    info=processFiles(info,files);

    displayInfo(info);

    opts.pp('\n\n');

    if nargout>0
        varargout{1}=info;
    end

end

function info=processFiles(info,files)

    filesToClean={};
    opts=info.opts;

    function fInfo=process(f)
        fInfo=preprocessFile(opts,f);

        if isempty(fInfo)


            opts.pp('\n');
            opts.ppMsg('UpgradeSkippingFile',f);
            return;
        end

        strOrig=fileread(fInfo.dstFile);
        [strNew,replacements]=upgradeContents(opts,strOrig);

        fInfo.hasChanged=~isequal(strOrig,strNew);
        fInfo.replacements=replacements;



        filesToClean{end+1}=fInfo.tempFile;
        if fInfo.hasChanged
            if doBackup(opts,fInfo)
                str2file(opts,strNew,fInfo.dstFile);
            else

                fInfo=[];
                return;
            end
        end
    end


    try
        info.files=cell(1,numel(files));
        I=false(1,numel(files));
        for i=1:numel(files)
            f=files{i};
            info.files{i}=process(f);
            if isempty(info.files{i})
                I(i)=true;
            end
        end
    catch ME
        genCleanup(opts,filesToClean);
        rethrow(ME);
    end
    info.files(I)=[];
    genCleanup(opts,filesToClean);

end


function doCleanup(opts)
    if~isfolder(opts.logDir)
        error(message('Coder:common:UpgradeNoLogDir'));
    end

    currDir=pwd;
    try
        cd(opts.logDir);
        fschange(pwd);
        if isfile('coderUpgradeCleanup.m')
            q1=message('Coder:common:UpgradeConfirmCleanup');
            q2=message('Coder:common:UpgradeContinue');
            qq=sprintf('%s\n%s ',q1.getString(),q2.getString());
            while true
                if~isempty(opts.input)

                    s=opts.input;
                else
                    s=input(qq,'s');
                end
                switch s
                case 'Y'
                    break;
                case 'N'
                    m=message('Coder:common:UpgradeAbort');
                    disp(m.getString());
                    cd(currDir);
                    return;
                otherwise
                    m=message('Coder:common:UpgradeYOrN');
                    disp(m.getString());
                end
            end
            coderUpgradeCleanup();
            m=message('Coder:common:UpgradeCleanupLogDir',opts.logDir);
            disp(m.getString());

        end
    catch ME
        cd(currDir);
        rethrow(ME)
    end
    cd(currDir);

end

function genCleanup(opts,files)
    fCleanup=fullfile(opts.logDir,'coderUpgradeCleanup.m');
    fid=fopen(fCleanup,'w');
    fprintf(fid,'function coderUpgradeCleanup\n');
    fprintf(fid,'%% Custom cleanup function generated by coder.upgrade.\n');
    fprintf(fid,'%% \n');
    fprintf(fid,'%% This function deletes the temporary files created by the last\n');
    fprintf(fid,'%% run of coder.upgrade.\n');
    fprintf(fid,'\n');
    fprintf(fid,'files = {...\n');
    for i=1:numel(files)
        f=files{i};
        fprintf(fid,'  ''%s''\n',f);
    end
    fprintf(fid,'   };\n');
    fprintf(fid,'\n');
    fprintf(fid,'cleanupDir = ''%s'';\n',pwd);
    fprintf(fid,'currDir = pwd;\n');
    fprintf(fid,'try\n');
    fprintf(fid,'   cd(cleanupDir);\n');
    fprintf(fid,'   \n');
    fprintf(fid,'   for i = 1:numel(files)\n');
    fprintf(fid,'     f = files{i};\n');
    fprintf(fid,'     if isfile(f)\n');
    fprintf(fid,'        delete(f);\n');
    fprintf(fid,'        fprintf(1,''Deleting %%s\\n'',f);\n');
    fprintf(fid,'     end\n');
    fprintf(fid,'   end\n');
    fprintf(fid,'catch ME\n');
    fprintf(fid,'   cd(currDir);\n');
    fprintf(fid,'   rethrow(ME);\n');
    fprintf(fid,'end\n');
    fprintf(fid,'cd(currDir);\n');
    fprintf(fid,'\n');
    fprintf(fid,'end\n');
    fclose(fid);
end

function fInfo=preprocessFile(opts,f)



    fInfo=[];

    srcFile=f;
    dstFile=f;
    tempFile='';
    refFile='';
    backupFile='';
    if opts.preserve
        [path,name,ext]=fileparts(srcFile);

        dstFile=fullfile(path,[name,ext,'_upgraded']);
        tempFile=dstFile;
        refFile=srcFile;
        ok=copyfile(srcFile,dstFile);
        if~ok
            opts.pp('\n');
            opts.ppMsg('UpgradeCreationFailed',dstFile);
            return;
        end
        fileattrib(dstFile,'+w');
    end
    if opts.backup
        [path,name,ext]=fileparts(srcFile);
        backupFile=fullfile(path,[name,ext,'_backup']);
        dstFile=srcFile;
        tempFile=backupFile;
        refFile=backupFile;
    end

    fInfo.srcFile=srcFile;
    fInfo.dstFile=dstFile;
    fInfo.tempFile=tempFile;
    fInfo.refFile=refFile;
    fInfo.backupFile=backupFile;
end


function ok=doBackup(opts,fInfo)
    if isempty(fInfo.backupFile)
        ok=true;
        return;
    end
    opts.ppMsg('UpgradeBackingUp',fInfo.srcFile,fInfo.backupFile);
    opts.pp('\n');
    ok=copyfile(fInfo.srcFile,fInfo.backupFile);
    if~ok
        opts.ppMsg('UpgradeBackupFailed',fInfo.srcFile);
    end
end


function opts=defaultOptions
    opts=struct;
    opts.debug=false;
    opts.parseOptionsOnly=false;
    opts.files={};
    opts.preserve=false;
    opts.backup=true;
    opts.logDir=fullfile(pwd,'coder_upgrade');
    opts.logFile='upgradeLog.txt';
    opts.emlmexReplacement='codegen';
    opts.doCleanupOnly=false;
    opts.input=[];
    [ppShow,ppShowMsg]=genPP(1);

    opts.ppLog=@ppDummy;
    opts.ppShow=ppShow;
    opts.pp=@ppDummy;
    opts.ppMsg=@ppDummy;
    opts.ppLogMsg=@ppDummy;
    opts.ppShowMsg=ppShowMsg;

end

function opts=parseArgs(opts,varargin)
    argc=1;
    nargs=numel(varargin);

    arg='';

    function errUnrecognizedOption()
        error(message('Coder:common:UpgradeUnrecognizedOption',arg));
    end

    function errMissingParameter()
        error(message('Coder:common:UpgradeMissingParameter',arg));
    end

    function errCannotProcessOptions()
        error(message('Coder:common:UpgradeNonStringOption'));
    end

    function errExpectedCellArrayOfStrings(classA)
        error(message('Coder:common:UpgradeCellOfStrings',classA));
    end
    function a=itCurrent()
        if argc>numel(varargin)
            errMissingParameter();
        end
        a=varargin{argc};
    end

    function b=itHasCurrent()
        b=argc<=nargs;
    end

    function itAdvance()
        argc=argc+1;
    end

    while itHasCurrent()
        arg=itCurrent();
        if iscell(arg)
            for i=1:numel(arg)
                a=arg{i};
                if ischar(a)
                    opts.files{end+1}=a;
                else
                    errExpectedCellArrayOfStrings(class(a));
                end
            end
        elseif ischar(arg)

            arg=strtrim(arg);
            if numel(arg)>=1&&coder.internal.isOptionPrefix(arg(1))
                arg=arg(2:end);
                switch arg
                case 'debug'
                    opts.debug=true;
                case 'preserve'
                    opts.preserve=true;
                    opts.backup=false;
                case 'log'
                    itAdvance();
                    opts.logDir=itCurrent();
                case 'parseOptionsOnly'
                    opts.parseOptionsOnly=true;
                case 'fiaccel'
                    opts.emlmexReplacement='fiaccel';
                case 'cleanup'
                    opts.doCleanupOnly=true;
                case 'input'
                    itAdvance();
                    opts.input=itCurrent();
                otherwise
                    errUnrecognizedOption();
                end
            else
                opts.files{end+1}=arg;
            end
        else
            errCannotProcessOptions();
        end
        itAdvance();
    end
end


function opts=setupLogging(opts,logDir,logFile)



    if isfolder(logDir)
        opts.ppShowMsg('UpgradeLogExists',logDir);
        opts.ppShow('\n');
        files=dir(logDir);


        archiveDir=fullfile(logDir,'archive');
        hasArchive=isfolder(archiveDir);
        if(~hasArchive&&numel(files)>2)||(hasArchive&&numel(files)>3)
            dirName=['archive_',datestr(files(1).datenum,'yyyy_mm_dd_HH_MM_SS')];
            if~isfolder(archiveDir)
                mkdir(archiveDir);
            end
            stampedDir=fullfile(archiveDir,dirName);
            cnt=1;



            while isfolder(stampedDir)&&cnt<100
                stampedDir=fullfile(archiveDir,[dirName,'_',num2str(cnt)]);
                cnt=cnt+1;
            end
            opts.ppShowMsg('UpgradeArchiving',stampedDir);
            opts.ppShow('\n');
            mkdir(stampedDir);
            for i=1:numel(files)
                f=files(i);
                if~isempty(regexp(f.name,'^(archive|\.|\.\.)$','once'))

                else
                    movefile(fullfile(logDir,f.name),stampedDir);
                end
            end
        end
    else
        opts.ppShowMsg('UpgradeCreateLog',logDir);
        opts.ppShow('\n');
        mkdir(logDir);
    end

    logFullFile=fullfile(logDir,logFile);
    fid=fopen(logFullFile,'w');
    if fid==-1
        error(message('Coder:common:UpgradeLogFileFailed',logFullFile));
    end
    fclose(fid);

    [ppLog,ppLogMsg]=genPP(logFullFile);
    opts.ppLog=ppLog;
    opts.ppLogMsg=ppLogMsg;

    opts.pp=genTee(opts.ppShow,opts.ppLog);
    opts.ppMsg=genTee(opts.ppShowMsg,opts.ppLogMsg);

    opts.ppLogMsg('UpgradeLogFileCreated',logFullFile,datestr(now));

end

function ff=genTee(f1,f2)
    function f(varargin)
        f1(varargin{:});
        f2(varargin{:});
    end
    ff=@f;
end


function F=getListOfFiles(opts)

    filesOrDir=opts.files;
    recursive=true;

    if~iscell(filesOrDir)
        filesOrDir={filesOrDir};
    end

    files=cell(1,numel(filesOrDir));
    numFiles=0;
    dirs=cell(1,numel(filesOrDir));
    numDirs=0;
    for i=1:numel(filesOrDir)
        fd=filesOrDir{i};
        validateattributes(fd,{'char'},{'vector'},'coder.upgrade','fileOrDir');


        fdwhich=which(fd);
        if isfile(fdwhich)
            fd=fdwhich;
        end

        fd=fullfile(fd);
        if isfolder(fd)
            numDirs=numDirs+1;
            dirs{numDirs}=fd;
        elseif isfile(fd)
            numFiles=numFiles+1;
            files{numFiles}=fd;
        else
            opts.ppMsg('UpgradeNoSuchFile',fd);
            opts.pp('\n');
        end
    end

    files=files(1:numFiles);
    dirs=dirs(1:numDirs);


    I=true(size(files));
    for i=1:numel(files)
        f=files{i};
        I(i)=checkFile(f);
    end
    files(~I)=[];

    [~,logDirName]=fileparts(opts.logDir);
    [~,lfName,lfExt]=fileparts(opts.logFile);
    logFileName=[lfName,lfExt];

    function files=getFiles(d)
        files={};
        dfs=dir(d);
        for j=1:numel(dfs)
            dj=dfs(j);
            name=dj.name;
            switch name
            case{'.','..'}
                continue;
            case{logDirName,logFileName}
                continue;
            otherwise
            end
            name=fullfile(d,name);
            if dj.isdir
                if recursive
                    files=[files,getFiles(name)];%#ok
                end
            elseif checkFile(dj.name,true)
                files=[files,{name}];%#ok
            end
        end
    end

    for i=1:numel(dirs)
        d=dirs{i};
        files=[files,getFiles(d)];%#ok
    end

    F=files;

    if isempty(F)
        opts.ppMsg('UpgradeNoFilesFound');
        opts.pp('\n');
    else
        opts.ppLog('\n');
        opts.ppLogMsg('UpgradeFilesToProcess');
        opts.ppLog('PP:indent++');
        for i=1:numel(F)
            opts.ppLog('\n%s',F{i});
        end
        opts.ppLog('PP:indent--');
    end
end



function ok=checkFile(f,silent)
    if nargin==1
        silent=false;
    end

    X=supportedFileExtensions();
    [~,~,ext]=fileparts(f);

    ok=true;
    if~ismember(lower(ext),X)
        if~silent
            btStruct=warning('QUERY','BACKTRACE');
            warning('OFF','BACKTRACE');
            warning(message('Coder:common:UpgradeInvalidExtensionSkipping',ext,f));
            warning(btStruct);
        end
        ok=false;
    end

end


function X=supportedFileExtensions
    X={'.m'};
end


function ppDummy(varargin)

end


function[ppf,ppMsgf]=genPP(file)

    indentLevel=0;
    logFile=file;

    function ppMsg(msgId,varargin)

        a=message(['Coder:common:',msgId],varargin{:});
        pp('%s',a.getString());

    end
    function pp(fmt,varargin)






        indentMax=21;
        indentStep=3;

        function doPrint(fid)
            s=sprintf(fmt,varargin{:});
            space=repmat(' ',1,indentLevel);
            s=regexprep(s,'\n',['\n',space]);
            fprintf(fid,'%s',s);
        end

        switch fmt
        case 'PP:indent++'
            indentLevel=indentLevel+indentStep;
            if indentLevel>indentMax
                indentLevel=0;
            end
        case 'PP:indent--'
            indentLevel=indentLevel-indentStep;
            if indentLevel<0
                indentLevel=indentMax;
            end
        otherwise
            if isempty(logFile)

            elseif~ischar(logFile)
                doPrint(logFile);
            else
                fid=fopen(logFile,'a');
                doPrint(fid);
                fclose(fid);
            end
        end
    end

    ppf=@pp;
    ppMsgf=@ppMsg;

end


function[s,replacements]=upgradeContents(opts,s)

    T=mtree(s);

    if count(mtfind(T,'Kind','ERR'))~=0
        btStruct=warning('QUERY','BACKTRACE');
        warning('OFF','BACKTRACE');
        warning(message('Coder:common:UpgradeParseError'));
        warning(btStruct);
    end
    R=findReplacements(opts,T);


    [st,en]=regexp(s,'%#eml');
    for i=1:numel(st)
        r=rawReplacement(st(i),en(i),'%#codegen',[]);
        R=[R,r];%#ok
    end

    replacements=logReplacements(s,R);
    s=applyReplacements(R,s);

end

function r=rawReplacement(startPos,endPos,string,note)
    r.startPos=startPos;
    r.endPos=endPos;
    r.string=string;
    r.note=note;
end

function replacements=logReplacements(s,R)
    replacements=[];
    if isempty(R)
        return;
    end

    lineColMap=computeLineColMap(s);
    for i=1:numel(R)
        ri=R(i);
        startLine=lineColMap.getLineColumn(ri.startPos);
        rep=struct(...
        'startLine',num2cell(startLine),...
        'note',ri.note,...
        'match',s(ri.startPos:ri.endPos),...
        'replacement',ri.string);
        replacements=[replacements,rep];%#ok
    end
end


function R=findReplacements(opts,T)
    R=[];

    function replace(pStart,pEnd,str,note,offset)
        assert(nargin>=3);
        if nargin<4
            note=[];
        end
        if nargin<5
            offset=0;
        end
        if isa(pStart,'mtree')
            lp=lefttreepos(pStart)+offset;
        else
            lp=pStart+offset;
        end
        if isa(pEnd,'mtree')
            rp=righttreepos(pEnd)+offset;
        else
            rp=pEnd+offset;
        end

        assert(numel(lp)==numel(rp));
        for i=1:numel(lp)
            r=rawReplacement(lp(i),rp(i),str,note);
            R=[R,r];%#ok
        end
    end

    function r_typeof(T,outerOffset)
        if nargin==1
            outerOffset=0;
        end


        function worker(T,offset)
            for i=indices(T)
                E=T.select(i);
                ARGS=mtpath(E,'Right.List');
                n=count(ARGS)-offset;
                p=rightposition(E);
                switch n
                case 1,replace(p,p-1,',[],1',[],outerOffset);
                case 2,replace(p,p-1,',1',[],outerOffset);
                otherwise
                end
            end
        end

        EGS=mtfind(T,'Kind','SUBSCR','Left.Kind','DOT','Left.Left.String','emlcoder','Left.Right.String','egs');
        FCN=mtpath(EGS,'Left');
        replace(FCN,FCN,'coder.typeof',4,outerOffset);
        worker(EGS,0);

        EXAMPLE=mtfind(T,'Kind','SUBSCR','Left.Kind','DOT','Left.Left.String','emlcoder','Left.Right.String','Example','Right.String','''size''');
        SIZESTR=mtpath(EXAMPLE,'Right.Next');
        replace(EXAMPLE,lefttreepos(SIZESTR)-1,'coder.typeof(',4,outerOffset);
        worker(EXAMPLE,1);
    end

    function r_constant(T,offset)
        if nargin==1
            offset=0;
        end
        C=mtfind(T,'Kind','DOT','Left.String','emlcoder','Right.String','egc');
        replace(C,C,'coder.Constant',[],offset);

        EX=mtfind(T,'Kind','SUBSCR','Left.Kind','DOT','Left.Left.String','emlcoder','Left.Right.String','Example','Right.String','''const''');
        N=mtpath(EX,'Right.Next');
        replace(EX,offset+lefttreepos(N)-1,'coder.Constant(',[],offset);
    end

    function r_eml(T)
        EMLDOT=mtfind(T,'Kind','DOT','Left.String','eml');
        EML=mtpath(EMLDOT,'Left');
        replace(EML,EML,'coder');
    end

    function r_compilerOptions(T)
        CO=mtfind(T,'Kind','DOT','Left.String','emlcoder','Right.String','CompilerOptions');
        replace(CO,CO,'coder.mexconfig');
    end

    function r_hardwareImplementation(T)
        HW=mtfind(T,'Kind','DOT','Left.String','emlcoder','Right.String','HardwareImplementation');
        replace(HW,HW,'coder.HardwareImplementation');
    end

    function r_rtwConfig(T)
        CFG=mtfind(T,'Kind','DOT','Left.String','emlcoder','Right.String','RTWConfig');
        for i=indices(CFG)
            CI=CFG.select(i);
            P=CI.Parent;
            recognizedCall=false;
            if iskind(P,'SUBSCR')&&P.Left==CI
                s=strings(P.Right);
                if numel(s)==1
                    s=s{1};
                    if strcmpi(s,'''ert''')
                        recognizedCall=true;
                        replace(P,P,'coder.config(''lib'',''ecoder'',true)',3);
                    elseif strcmpi(s,'''grt''')
                        recognizedCall=true;
                        replace(P,P,'coder.config(''lib'',''ecoder'',false)',3);
                    end
                end
            end
            if~recognizedCall
                replace(CI,CI,'coder.config(''lib'')');
            end
        end
    end

    function r_mexConfig(T)
        CFG=mtfind(T,'Kind','DOT','Left.String','emlcoder','Right.String','MEXConfig');
        replace(CFG,CFG,'coder.config(''mex'')');
    end
    function r_simpleDots(T,oldName,newName)
        D=mtfind(T,'Kind','DOT','Right.String',oldName);
        N=mtpath(D,'Right');
        replace(N,N,newName);
    end

    function r_CustomSymbolStrFcnArg(T)
        D=mtfind(T,'Kind','DOT','Right.String','CustomSymbolStrFcnArg');
        N=mtpath(D,'Right');
        replace(N,N,'CustomSymbolStrFcnArg',6);
    end

    function r_emlc_emlmex(T)





        CALLS=mtfind(T,'Kind','CALL','Left.String',{'emlc','emlmex','codegen','fiaccel'});
        CALLS=CALLS|mtfind(T,'Kind','DCALL','Left.String',{'emlc','emlmex','codegen','fiaccel'});

        FCNS=mtpath(CALLS,'Left');
        EMLMEX=mtfind(FCNS,'String','emlmex');
        replace(EMLMEX,EMLMEX,opts.emlmexReplacement,1);
        EMLC=mtfind(FCNS,'String','emlc');
        replace(EMLC,EMLC,'codegen');

        ARGS=mtpath(CALLS,'Right.List');

        function ss=wrapStr(s)
            if iscell(s)
                ss=cellfun(@(str)['''',str,''''],s,'UniformOutput',false);
            elseif ischar(s)
                ss=['''',s,''''];
            else
                assert(false);
            end
        end

        function b=id(a)
            b=a;
        end

        function recursiveStringArgs(ARGS)


            argNames={'-eg','-global','-globals','-args'};
            argNames=[argNames,wrapStr(argNames)];

            A=mtfind(ARGS,'String',argNames);
            for i=indices(A)
                ai=A.select(i);
                val=strings(mtpath(ai,'Next.String'));
                if numel(val)==1
                    val=val{1};
                    offset=0;
                    if numel(val)>2&&val(1)==''''&&val(end)==''''
                        val=val(2:end-1);






                        quote='''';
                        reps={[quote,quote,'([\w-])'],[quote,' $1'];...
                        ['(\S)',quote,quote],['$1 ',quote]};

                        val=regexprep(val,reps(:,1),reps(:,2));
                        offset=1;
                    end
                    if~isempty(val)
                        TVal=mtree(val);


                        offset=offset+lefttreepos(ai.Next)-1;
                        r_typeof(TVal,offset);
                        r_constant(TVal,offset);
                    end
                end
            end
        end

        function argsHelper(ARGS,oldArgs,str,note)
            if nargin<4
                note=[];
            end
            A=mtfind(ARGS,'String',oldArgs);
            replace(A,A,str,note);
            A=mtfind(ARGS,'String',wrapStr(oldArgs));
            replace(A,A,wrapStr(str),note);
        end

        argsHelper(ARGS,'-eg','-args');
        argsHelper(ARGS,'-global','-globals');
        argsHelper(ARGS,'-s','-config',2);


        recursiveStringArgs(ARGS);

        function r_T(ARGS,fWrap)
            DT=mtfind(ARGS,'String',fWrap('-T'));
            for i=indices(DT)
                TI=DT.select(i);
                s=strings(TI.Next);
                matched=false;
                if numel(s)==1
                    s=s{1};
                    if strcmpi(s,fWrap('rtw:exe'))
                        replace(TI,TI.Next,fWrap('-config:exe'),2);
                        matched=true;
                    elseif strcmpi(s,fWrap('rtw:lib'))
                        replace(TI,TI.Next,fWrap('-config:lib'),2);
                        matched=true;
                    elseif strcmpi(s,fWrap('rtw'))
                        replace(TI,TI.Next,fWrap('-config:lib'),2);
                        matched=true;
                    elseif strcmpi(s,fWrap('mex'))
                        replace(TI,TI.Next,fWrap('-config:mex'),2);
                        matched=true;
                    end
                end
                if~matched
                    replace(TI,TI,fWrap('-config'),2);
                end
            end
        end

        r_T(ARGS,@wrapStr);
        r_T(ARGS,@id);
    end

    r_typeof(T);
    r_constant(T);
    r_eml(T);
    r_compilerOptions(T);
    r_hardwareImplementation(T);
    r_CustomSymbolStrFcnArg(T);








    r_simpleDots(T,'RTWCompilerOptimization','CCompilerOptimization');
    r_simpleDots(T,'RTWCustomCompilerOptimizations','CCompilerCustomOptimizations');
    r_simpleDots(T,'MultiInstanceERTCode','MultiInstanceCode');
    r_simpleDots(T,'IncludeMdlTerminateFcn','IncludeTerminateFcn');
    r_simpleDots(T,'RTWVerbose','Verbose');
    r_rtwConfig(T);
    r_mexConfig(T);
    r_emlc_emlmex(T);

end


function s=applyReplacements(R,s)
    if isempty(R)
        return;
    end

    [~,I]=sort([R.startPos]);
    R=R(I);



    n=numel(R);
    buf=cell(1,2*n);
    j=1;
    pbegin=1;
    for i=1:n
        ri=R(i);
        buf{j}=s(pbegin:ri.startPos-1);
        j=j+1;
        buf{j}=ri.string;
        j=j+1;
        pbegin=ri.endPos+1;
    end
    buf{j}=s(pbegin:end);

    s=[buf{:}];

end


function displayInfo(info)
    opts=info.opts;
    files=info.files;
    n=numel(files);

    maxSrcFileSize=20;
    maxDstFileSize=20;
    for i=1:n
        f=files{i};
        maxSrcFileSize=max(numel(f.srcFile),maxSrcFileSize);
        maxDstFileSize=max(numel(f.dstFile),maxDstFileSize);
    end

    maxColWidth=50;
    srcFileColSize=min(maxSrcFileSize,maxColWidth);
    dstFileColSize=min(maxDstFileSize,maxColWidth);

    hasNotes=false;
    for i=1:n
        f=files{i};

        srcFile=truncate(f.srcFile,srcFileColSize);
        dstFile=truncate(f.dstFile,dstFileColSize);
        opts.ppShow('\n%*s ==> %*s    ',srcFileColSize,srcFile,dstFileColSize,dstFile);
        opts.ppLog('\n%*s ==> %*s    ',srcFileColSize,f.srcFile,dstFileColSize,f.dstFile);
        opts.pp('PP:indent++');
        displayReplacements(opts,f.replacements);
        if f.hasChanged
            if isempty(f.refFile)

            else

                opts.ppLog('\n');
                opts.ppShow('<a href="matlab:visdiff(''%s'',''%s'')">',f.refFile,f.dstFile);
                opts.ppShowMsg('UpgradeDifference');
                opts.ppShow('</a>');
                opts.ppLog('>> visdiff(''%s'',''%s'');\n',f.refFile,f.dstFile);

                notes=unique([f.replacements.note]);
                if~isempty(notes)
                    opts.ppShow('  ');
                    opts.ppShowMsg('UpgradeNote');
                    opts.ppShow(': ');
                    for j=1:numel(notes)
                        opts.ppShow('%d',notes(j));
                        if j<numel(notes)
                            opts.ppShow(' ');
                        end
                    end
                    hasNotes=true;
                end
            end
        else
            opts.ppMsg('UpgradeNoChange');
        end

        opts.pp('PP:indent--');

    end

    if hasNotes
        opts.pp('\n\n');
        opts.ppMsg('UpgradeExplainNotes');
    end

end

function s=truncate(s,n)

    ns=numel(s);
    if ns>n&&n>3


        s=['...',s((ns-(n-3)+1):ns)];
    end
end

function displayReplacements(opts,replacementLog)
    if isempty(replacementLog)
        return;
    end
    [~,I]=sort([replacementLog.startLine]);
    replacementLog=replacementLog(I);
    for i=1:numel(replacementLog)
        R=replacementLog(i);
        opts.ppLog('\n');
        opts.ppLogMsg('UpgradeLine');
        if isempty(R.replacement)


            opts.ppLog(' %4d: %20s',R.startLine,R.match);
        else
            opts.ppLog(' %4d: %-20s ==>  %-20s',R.startLine,R.match,R.replacement);
        end
        if~isempty(R.note)
            opts.ppLog('PP:indent++');
            opts.ppLog('\n');
            opts.ppLogMsg('UpgradeNote');
            opts.ppLog(': %d',R.note);
            opts.ppLog('PP:indent--');
        end
    end
end


function X=computeLineColMap(s)




    function pNL=findPrecedingNewLine(p)
        nl=newline;
        if p>numel(s)
            p=numel(s);
        end
        for i=p:-1:1
            if s(i)==nl
                pNL=i;
                return;
            end
        end
        pNL=0;
    end

    function[l,c]=getLineColumn(p)


        pNL=findPrecedingNewLine(p);
        l=m(pNL);
        c=p-pNL;
    end

    nls=regexp(s,'\n');
    if isempty(nls)
        m=containers.Map(0,2:2);
    else
        m=containers.Map(nls,2:numel(nls)+1);
    end
    m(0)=1;
    X.s=s;
    X.m=m;
    X.getLineColumn=@getLineColumn;
end


function str2file(opts,str,filename)

    [fid,msg]=fopen(filename,'w');

    if fid==-1
        opts.ppMsg('UpgradeFailedToOpen',filename,msg);
        opts.pp('\n');
        error(message('Coder:common:UpgradeFailedToOpen',filename,msg));
    end
    fprintf(fid,'%s',str);
    fclose(fid);

end
