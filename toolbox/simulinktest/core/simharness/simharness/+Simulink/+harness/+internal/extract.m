function[harnessH,portInfo,error_occ,extractSubsysExc]=extract(subsysOrMdlref,mdlrefMode,varargin)




    narginchk(2,3);

    portInfo=[];
    harnessH=-1;

    featureOn=slfeature('UnifiedHarnessExtract')>0;
    assert(featureOn,'UnifiedHarnessExtract feature should be on when calling extractSubsystem');

    try
        model=bdroot(subsysOrMdlref);
        wasSLDV=get_param(model,'InSLDVAnalysis');
        oc=onCleanup(@()set_param(model,'InSLDVAnalysis',wasSLDV));
        set_param(model,'InSLDVAnalysis','on');
        harnessName=getNameForExtract(subsysOrMdlref,model,mdlrefMode);
        modelH=get_param(model,'Handle');
        subsysH=get_param(subsysOrMdlref,'Handle');
        origDirty=get_param(modelH,'Dirty');
        oc1=onCleanup(@()set_param(modelH,'Dirty',origDirty));
        wstate=warning;
        warning('off','Simulink:Harness:ExportDeleteHarnessFromSystemModel');
        warning('off','Simulink:Harness:IndHarnessDetachWarning');
        warning('off','Simulink:Harness:HarnessDeletedIndependentHarness');
        warning('off','Simulink:Harness:WarnTermAdded');
        oc2=onCleanup(@()warning(wstate));



        createCallback=false;
        if nargin==3
            createCallback=varargin{1};
            validateattributes(createCallback,{'logical'},{'scalar'});
        end
        if createCallback
            cbFile='Simulink.harness.internal.groundOrTermAutogeneratedIO';
        else
            cbFile='';
        end


        if strcmp(get_param(model,'Lock'),'on')
            Simulink.harness.internal.setBDLock(model,false);
            oc3=onCleanup(@()Simulink.harness.internal.setBDLock(model,false));
        end

        saveExternally=false;
        if Simulink.harness.internal.isSavedIndependently(modelH)
            saveExternally=true;
        end

        extractMode=1;
        if sldvshareprivate('util_is_analyzing_for_fixpt_tool')
            extractMode=2;
        end
        prevVal2=slsvTestingHook('UnifiedHarnessBackendMode',extractMode);
        cleanupFeatureSetting3=onCleanup(@()slsvTestingHook('UnifiedHarnessBackendMode',prevVal2));


        [tsInfo,cleanupObjs,error_occ,extractSubsysExc]=Simulink.harness.internal.preProcessForExtract(modelH,subsysH);
        if error_occ
            for i=1:length(cleanupObjs)
                cleanupObjs(i).delete;
            end
            return;
        end

        if strcmpi(get_param(modelH,'IsHarness'),'on')
            harnessSysH=modelH;
            mainSysH=get_param(get_param(harnessSysH,'OwnerBDName'),'Handle');

            oldTagValue=get_param(subsysOrMdlref,'Tag');
            if strcmp(oldTagValue,'__SL_testing_harness_stub_')
                set_param(subsysOrMdlref,'Tag','');
                oc3=onCleanup(@()set_param(subsysOrMdlref,'Tag',oldTagValue));
            end
            enableExtract=Simulink.harness.internal.EnableCreateForHarnessBD(mainSysH,harnessSysH);%#ok 
            saveExternally=false;
        end

        set_param(model,'Dirty','off');
        args={subsysOrMdlref,...
        false,...
        false,...
        'Source','Inport',...
        'Name',harnessName,...
        'AutoShapeInputs',false,...
        'DriveFcnCallWithTestSequence',false,...
        'SynchronizationMode','SyncOnOpen',...
        'SaveExternally',saveExternally,...
        'RebuildOnOpen',false,...
        'PostCreateCallback',cbFile,...
        'SLDVCompatible',true};





        if(~mdlrefMode&&strcmp(get_param(subsysH,'IsSimulinkFunction'),'on'))||...
            (mdlrefMode&&...
            strcmpi(get_param(subsysOrMdlref,'IsModelRefExportFunction'),'on'))
            args{end+1}='SchedulerBlock';
            args{end+1}='Matlab Function';
        end
        Simulink.harness.internal.create(args{:});
        for i=1:length(cleanupObjs)
            cleanupObjs(i).delete;
        end

        Simulink.harness.internal.load(subsysOrMdlref,harnessName,false);
        harnessH=get_param(harnessName,'Handle');


        tsInfo.extractMode=extractMode;
        portInfo=Simulink.harness.internal.postProcessForExtract(modelH,subsysH,harnessH,tsInfo);
        if slfeature('SLModelAllowedBaseWorkspaceAccess')>0
            set_param(harnessName,'EnableAccessToBaseWorkspace',...
            get_param(get_param(modelH,'Name'),'EnableAccessToBaseWorkspace'))
        end
        if saveExternally
            save_system(harnessName);
        end
        Simulink.harness.internal.export(subsysOrMdlref,harnessName,false);

        harnessH=get_param(harnessName,'Handle');
    catch ME
        close_system(harnessName,0);
        harnessH=-1;
        error_occ=true;
        extractSubsysExc=ME;

        if strcmp(extractSubsysExc.identifier,'Simulink:Harness:NoSupportAsynchTrigSampleTimeSubSystem')
            extractSubsysExc=MException('Sldv:Compatibility:AtomicSSExtraction:CheckPorts',...
            extractSubsysExc.message);
        end
    end

end

function harnessName=getNameForExtract(subsys,model,mdlrefMode)
    subsysName=get_param(subsys,'Name');
    mdlName=get_param(model,'Name');
    subsysName=matlab.lang.makeValidName(subsysName);

    availableHarnessList=Simulink.harness.internal.getHarnessList(mdlName,'all');
    deletedHarnessNames=Simulink.harness.internal.getDeletedHarnessNames(mdlName);

    allHarnessNames={};
    if~isempty(availableHarnessList)
        names={availableHarnessList.name};
        allHarnessNames=[allHarnessNames,names];
    end
    if~isempty(deletedHarnessNames)
        allHarnessNames=[allHarnessNames,deletedHarnessNames];
    end

    if length(subsysName)>40
        subsysName=subsysName(1:40);
    end
    inMemoryModels=lower(find_system('type','block_diagram'));






    if(~mdlrefMode&&strcmp(get_param(subsys,'IsSimulinkFunction'),'on'))
        id=0;
    else
        id=-1;
    end
    prefix=subsysName;

    while id<100

        if id==-1
            harnessName=prefix;
        else
            harnessName=[prefix,num2str(id)];
        end


        nameAlreadyUsed=false;
        [~,ind]=ismember(harnessName,allHarnessNames);
        if ind~=0
            nameAlreadyUsed=true;
        end

        nameConflictsWithInMemoryModels=false;
        [~,ind]=ismember(lower(harnessName),inMemoryModels);
        if ind~=0
            nameConflictsWithInMemoryModels=true;
        end

        nameIsShadowing=false;
        if~isempty(which(harnessName))
            nameIsShadowing=true;
        end
        if(~nameAlreadyUsed&&...
            ~nameIsShadowing&&...
            ~nameConflictsWithInMemoryModels)
            break;
        end
        id=id+1;
    end
end


