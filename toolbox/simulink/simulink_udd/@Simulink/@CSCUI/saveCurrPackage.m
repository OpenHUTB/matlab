function succeeded=saveCurrPackage(hUI)




    succeeded=false;

    filepath=hUI.RegFileInfo{1};
    filename=hUI.RegFileInfo{2};
    fileext=hUI.RegFileInfo{3};
    filelong=[filepath,filesep,filename,fileext];

    if isempty(filepath)||isempty(filename)
        msg=DAStudio.message('Simulink:dialog:CSCUICSCRegPathEmpty');
        errordlg(msg,...
        DAStudio.message('Simulink:dialog:CSCDesignerTitle'),'non-modal');
        return;
    end





    validateAll(hUI);



    msg=DAStudio.message('Simulink:dialog:CSCUISavingFile');
    waitBarPlsWait=DAStudio.message('Simulink:dialog:CSCUIFindPkgsPlsWait');
    hw=waitbar(0,msg,'Name',waitBarPlsWait);




    STR_FUNC=sprintf('function defs = %s(action)\n',filename);

    STR_COPYRIGHT_AND_REVISION=sprintf(strrep([...
    '\n',...
    '%   Copyright 1994-',datestr(date,'yyyy'),' The MathWorks, Inc.\n'...
    ,'%   $Revi','sion: $  $Da','te: $\n',...
'\n'...
    ],'%','%%'));

    STR_DISCLAIMER=sprintf(strrep([...
    '\n',...
    '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n',...
    '% NOTE:\n',...
    '% - This file was automatically generated by the Simulink custom storage class\n',...
    '%   designer.\n',...
    '% - The contents of this file are arranged so that the Simulink custom storage\n',...
    '%   class designer can load the associated classes for editing.\n',...
    '% - Hand modification of this file is not recommended as it may prevent the\n',...
    '%   Simulink custom storage class designer from loading the associated classes.\n',...
    '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n',...
    '% - Generated on:   ',datestr(now),'\n',...
    '% - MATLAB version: ',version,'\n',...
    '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n',...
'\n'...
    ],'%','%%'));

    STR_TAIL=sprintf('\n\n%%EOF\n');

    found_mark_line=false;
    lines_keep=[];




    fid=fopen(filelong,'r');
    if fid>=1

        while feof(fid)==0
            line=fgets(fid);
            if-1==line
                break;
            end



            matches=regexp(line,['^ *function +.* *= *',filename],'once');
            if isempty(matches)
                lines_keep=[lines_keep,line];%#ok
            end


            matches=regexp(line,'^ *%+ *Do not delete this line..* auto-generated *=+','once');



            if~isempty(matches)
                found_mark_line=true;
                break
            end
        end

        status=fclose(fid);
        if status<0
            msg=DAStudio.message('Simulink:dialog:CSCUICSCRegPathClose',filelong);
            errordlg(msg,...
            DAStudio.message('Simulink:dialog:CSCDesignerTitle'),'non-modal');
            if ishghandle(hw);close(hw);end
            return;
        end

    end




    fid=fopen(filelong,'w');
    if fid<1
        msg=DAStudio.message('Simulink:dialog:CSCUICSCRegPathOpen',filelong);
        errordlg(msg,...
        DAStudio.message('Simulink:dialog:CSCDesignerTitle'),'non-modal');
        if ishghandle(hw);close(hw);end
        return;
    end




    fwrite(fid,STR_FUNC,'char');

    if found_mark_line
        fwrite(fid,lines_keep,'char');
    else
        fwrite(fid,STR_COPYRIGHT_AND_REVISION,'char');
    end

    fwrite(fid,STR_DISCLAIMER,'char');




    fprintf(fid,'\n');
    fprintf(fid,'switch action\n');

    nl=sprintf('\n');

    for whichDefns=1:2
        switch whichDefns
        case 1
            strWhichDefn='CSCDefn';
        case 2
            strWhichDefn='MemorySectionDefn';
        end

        fprintf(fid,'\n');
        fprintf(fid,'  case ''%s''\n',strWhichDefn);
        fprintf(fid,'    defs = [];\n');

        for i=1:length(hUI.AllDefns{whichDefns})
            if ishghandle(hw);waitbar(i/length(hUI.AllDefns{whichDefns}),hw);end
            currDefn=hUI.AllDefns{whichDefns}(i);


            if((i==1)&&strcmp(currDefn.getProp('Name'),'Default'))
                continue;
            end


            if~isequal(currDefn.OwnerPackage,hUI.CurrPackage)
                currDefn.OwnerPackage=hUI.CurrPackage;
            end

            fprintf(fid,'\n');
            mscripts=obj2mstr(currDefn,'h','    ');


            if(whichDefns==1)
                if isAccessMethod(currDefn)
                    mscripts=strrep(mscripts,['        set(h.CSCTypeAttributes, ''AccessDataThroughMacro'', false);',nl],'');
                    mscripts=strrep(mscripts,['        set(h.CSCTypeAttributes, ''GetElementFunction'', ''get_el_$N'');',nl],'');
                    mscripts=strrep(mscripts,['        set(h.CSCTypeAttributes, ''SetElementFunction'', ''set_el_$N'');',nl],'');
                    mscripts=strrep(mscripts,['        set(h.CSCTypeAttributes, ''SupportsArrayAccess'', false);',nl],'');
                end
            end

            fwrite(fid,mscripts,'char');

            fprintf(fid,'    defs = [defs; h];\n');
        end
    end

    fprintf(fid,'\n');
    fprintf(fid,'  otherwise\n');
    fprintf(fid,'    DAStudio.error(''Simulink:dialog:CSCRegInvalidAction'', action);\n');
    fprintf(fid,'end  %% switch action\n');




    fwrite(fid,STR_TAIL,'char');




    status=fclose(fid);
    if status<0
        msg=DAStudio.message('Simulink:dialog:CSCUICSCRegPathClose',filelong);
        errordlg(msg,...
        DAStudio.message('Simulink:dialog:CSCDesignerTitle'),'non-modal');
        if ishghandle(hw);close(hw);end
        return;
    end




    hUI.RegFileInfo={filepath,filename,fileext};
    hUI.IsDirty=false;


    cached_defns=processcsc('GetAllDefnsFromCache',hUI.CurrPackage);
    new_defns=hUI.AllDefns;


    if isempty(cached_defns)


    elseif l_CachedDefnsBeingUpdated(cached_defns,new_defns)


        warnMsg=DAStudio.message('Simulink:dialog:CSCUIRestartMatlabWarn',hUI.CurrPackage);
        warndlg(warnMsg,DAStudio.message('Simulink:dialog:CSCDesignerTitle'),'non-modal');
    else


        processcsc('ClearCache',hUI.CurrPackage);
        processcsc('GetAllDefns',hUI.CurrPackage);
    end



    if ishghandle(hw);close(hw);end

    succeeded=true;





    function r=l_CachedDefnsEqualToNewOnes(cached_defns,new_defns)
        r=true;

        new_Names={};
        for k=1:length(new_defns)
            new_Names{end+1}=new_defns(k).Name;%#ok
        end

        for k=1:length(cached_defns)
            [found,idx]=ismember(cached_defns(k).Name,new_Names);
            isSame=(found&&isequal(cached_defns(k),new_defns(idx)));
            if~isSame

                r=false;
                break;
            end
        end


        function r=l_CachedDefnsBeingUpdated(cached_defns,new_defns)
            r=false;

            assert(iscell(cached_defns)&&(numel(cached_defns)==2)&&...
            iscell(new_defns)&&(numel(new_defns)==2));


            if~l_CachedDefnsEqualToNewOnes(cached_defns{1},new_defns{1})
                r=true;
                return;
            end


            if~l_CachedDefnsEqualToNewOnes(cached_defns{2},new_defns{2})
                r=true;
                return;
            end



