function importArchitecture(mapping,fileName,preserveProperties)








    args.fileName=fileName;
    args.preserveProperties=false;

    if nargin>2
        args.preserveProperties=preserveProperties;
    end

    try
        aTmp=mapping.Architecture;
        locImportArchitecture(mapping,args);
    catch E
        warning(E.identifier,'%s',E.message);
        mapping.Architecture=aTmp;
    end

    function locImportArchitecture(mapping,args)

        fileName=args.fileName;




        a1=Simulink.DistributedTarget.Architecture;
        if strcmp(fileName,'Multicore')||strcmp(fileName,'built-in')
            a1.Name='Multicore';
            a1.addNode('CPU','SoftwareNode');
        elseif strcmp(fileName,'archFromConnectedxPCTarget')
            a1=locGetArchFromConnectedTarget();
            if isempty(a1)
                return;
            end
        else
            Simulink.DistributedTarget.parseArchXML(fileName,a1,false);
        end

        a2=mapping.Architecture;



        lMaps=[];
        maps=mapping.BlockToNodesMap;
        for i=1:length(maps)
            lMaps(i).Block=maps(i).Block;%#ok
            lMaps(i).Paths=determinePaths(a2,maps(i).MappingEntities);%#ok
        end
        for i=1:length(lMaps)
            paths=lMaps(i).Paths;
            block=get_param(lMaps(i).Block,'Handle');
            for j=1:length(paths)
                mapping.unmap(block,paths(j).data{end});
            end
        end




        mapping.Architecture=a1;

        args.origArchitecture=a2;
        args.newArchitecture=a1;

        try



            entityPairs=associateEntities(args,...
            [],...
            [],mappableChildren(a2),...
            [],mappableChildren(a1));




            for i=1:length(lMaps)
                paths=lMaps(i).Paths;
                block=get_param(lMaps(i).Block,'Handle');

                for j=1:length(paths)
                    pair=findAssociatedEntity(entityPairs,paths(j).data);
                    if~isempty(pair)
                        mapping.map(block,pair.dstPath{end});
                    end
                end
            end



            ctd=get_param(mapping.ParentDiagram,'CompiledTaskDiagram');
            tc=[];
            trigger=[];
            for i=1:length(mapping.Architecture.Nodes)
                if isa(mapping.Architecture.Nodes(i),'Simulink.DistributedTarget.SoftwareNode')
                    tc=mapping.Architecture.Nodes(i).TaskConfiguration;
                    for j=1:length(tc.Triggers)
                        if strcmp(tc.Triggers(j).TriggerType,'PeriodicTrigger')
                            trigger=tc.Triggers(j);
                            break;
                        end
                    end
                    break;
                end
            end

            for i=1:length(ctd.AutogeneratedTasks)
                if isa(ctd.AutogeneratedTasks(i),'Simulink.SoftwareTarget.AutogenTask')
                    ctd.AutogeneratedTasks(i).ParentTrigger=trigger;
                else
                    assert(isa(ctd.AutogeneratedTasks(i),...
                    'Simulink.SoftwareTarget.AutogenTrigger'));
                    ctd.AutogeneratedTasks(i).ParentTaskConfiguration=tc;
                end
            end

        catch E
            warning(['Failed to synchronize imported architecture with existing mappings: '...
            ,E.message]);
            rethrow(E);
        end






        function createChildrenIfNeeded(args,o1,o2)

            assert(strcmp(class(o1),class(o2)));

            if isa(o1,'Simulink.DistributedTarget.SoftwareNode')
                tc1=o1.TaskConfiguration;
                tc2=o2.TaskConfiguration;


                for i=1:length(tc1.Triggers)
                    newTrigger=tc2.addTrigger(tc1.Triggers(i));
                    assert(isempty(newTrigger.TargetObject));
                    copyCompatibleProperties(args,tc1.Triggers(i),newTrigger);

                    if isa(newTrigger,'Simulink.SoftwareTarget.AperiodicTrigger')
                        newTrigger.createTargetObject();
                    end
                    for j=1:length(newTrigger.Tasks)
                        copyCompatibleProperties(args,tc1.Triggers(i).Tasks(j),...
                        newTrigger.Tasks(j));
                    end
                end



                tc2.deleteTrigger(tc2.Triggers(1));
            end

            if isa(o1,'Simulink.DistributedTarget.Node')
                copyCompatibleProperties(args,o1,o2);
            end








            function copyCompatibleProperties(args,origObj,newObj)

                if~args.preserveProperties,return;end

                newArch=args.newArchitecture;





                if~isempty(origObj.Template)&&...
                    (isempty(newObj.Template)||~newObj.Template.Implicit)

                    templates={newArch.Templates.Name};
                    template=newArch.Templates(strcmp(templates,origObj.Template.Name));

                    if~isempty(template)

                        if~strcmp(template(1).Type,origObj.Template.Type)


                            warning('Template with UUID has changed its type');
                        else
                            newObj.setTemplate(template(1));
                        end
                    end
                end


                if~isempty(newObj.Template)
                    propDefs=newObj.Template.TargetSpecificProperties;

                    for i=1:length(propDefs)
                        if origObj.hasProperty(propDefs(i).Name)&&propDefs(i).Editable
                            try %#ok This really is best effort, don't complain. 
                                val=origObj.getProperty(propDefs(i).Name);
                                newObj.setProperty(propDefs(i).Name,val);
                            end
                        end
                    end
                end






                function c=mappableChildren(o)

                    c=[];

                    if isa(o,'Simulink.DistributedTarget.Architecture')

                        c=o.Nodes;
                        swNodes=[];
                        hwNodes=[];
                        for i=1:length(c)
                            if isa(c(i),'Simulink.DistributedTarget.SoftwareNode')
                                swNodes=[swNodes,i];%#ok
                            else
                                hwNodes=[hwNodes,i];%#ok
                            end
                        end
                        c=[c(swNodes),c(hwNodes)];

                    elseif isa(o,'Simulink.DistributedTarget.SoftwareNode')

                        c=o.TaskConfiguration.Triggers;

                    elseif isa(o,'Simulink.SoftwareTarget.Trigger')

                        c=o.Tasks;

                    end






                    function entityPairs=associateEntities(args,...
                        entityPairs,...
                        path1,objs1,...
                        path2,objs2)



                        for i=1:length(objs1)
                            o1=objs1(i);
                            for j=1:length(objs2)
                                o2=objs2(j);
                                if~strcmp(class(o1),class(o2))
                                    continue;
                                end


                                objs2=objs2(j+1:end);


                                entityPair=[];
                                entityPair.srcPath=[path1,{o1}];
                                entityPair.dstPath=[path2,{o2}];
                                entityPairs=[entityPairs,entityPair];%#ok


                                createChildrenIfNeeded(args,o1,o2);

                                entityPairs=associateEntities(args,entityPairs,...
                                entityPair.srcPath,mappableChildren(o1),...
                                entityPair.dstPath,mappableChildren(o2));

                                break;
                            end
                        end





                        function entityPair=findAssociatedEntity(entityPairs,path_)

                            for i=1:length(entityPairs)
                                entityPair=entityPairs(i);
                                srcPath=entityPair.srcPath;

                                found=true;
                                if length(srcPath)~=length(path_)
                                    found=false;
                                else
                                    for j=1:length(srcPath)
                                        if srcPath{j}~=path_{j}
                                            found=false;
                                            break;
                                        end
                                    end
                                end

                                if found,return;end;
                            end
                            entityPair=[];





                            function[path_,found]=determinePath(path_,objs,entity)

                                found=false;
                                for i=1:length(objs)
                                    obj=objs(i);
                                    if obj==entity
                                        path_=[path_,{obj}];%#ok
                                        found=true;
                                        return;
                                    end

                                    [lpath_,found]=determinePath([path_,{obj}],...
                                    mappableChildren(obj),entity);
                                    if found
                                        path_=lpath_;
                                        return;
                                    end
                                end





                                function paths=determinePaths(arch,entities)

                                    paths=[];
                                    for i=1:length(entities)
                                        [pathCell,found]=determinePath([],mappableChildren(arch),entities(i));
                                        assert(found);
                                        pathObj=[];
                                        pathObj.data=pathCell;
                                        paths=[paths,pathObj];%#ok
                                    end





                                    function ret=locGetArchFromConnectedTarget()

                                        ret=[];

                                        try
                                            xPCArch=getArchFromTarget;
                                        catch E
                                            MSLDiagnostic('Simulink:mds:TargetConnectionFailed').reportAsWarning;
                                            rethrow(E);
                                        end

                                        if isempty(xPCArch)
                                            errordlg(DAStudio.message('Simulink:mds:TargetConnectionFailed'),...
                                            DAStudio.message('Simulink:taskEditor:ArchSelectorDialogErrorTitleText'),...
                                            'modal');
                                            return;
                                        end


                                        arch=Simulink.DistributedTarget.Architecture;
                                        arch.Name=xPCArch.name;
                                        arch.UUID='archFromConnectedxPCTarget';
                                        swNodeH={};


                                        assert(~isempty(xPCArch.nodes));
                                        for i=1:length(xPCArch.nodes)
                                            xPCNode=xPCArch.nodes(i);
                                            nodeH=arch.addNode(xPCNode.name,xPCNode.type);
                                            if~isempty(xPCNode.props)
                                                nodeT=arch.addTemplate(nodeH.Name);
                                                nodeT.Type=xPCNode.type;
                                                nodeT.Implicit=1;
                                                assert(strcmp(xPCNode.type,'HardwareNode'));
                                                for j=1:length(xPCNode.props)
                                                    if~strcmp(xPCNode.props(j).name,'Clock Frequency')
                                                        tp=nodeT.addTargetSpecificProperty(xPCNode.props(j).name,...
                                                        xPCNode.props(j).value);
                                                        tp.Editable=false;
                                                        tp.Evaluate=false;
                                                    else
                                                        nodeH.ClockFrequency=xPCNode.props(j).value;
                                                    end
                                                end
                                                nodeH.setTemplate(nodeT);
                                            end

                                            if strcmp(xPCNode.type,'SoftwareNode')

                                                assert(isempty(swNodeH));
                                                swNodeH=nodeH;
                                            end
                                        end

                                        if length(xPCArch.nodes)~=1

                                            for i=1:length(xPCArch.channelInterface)
                                                channelInterf=xPCArch.channelInterface(i);
                                                arch.addChannelInterface(channelInterf.Name,channelInterf.CodeGenClass);
                                            end


                                            for i=1:length(xPCArch.connection)
                                                connection=xPCArch.connection(i);
                                                arch.addConnection(connection.src,connection.dst,...
                                                connection.bidirectional,...
                                                connection.interf);
                                            end
                                        end


                                        for i=1:length(xPCArch.configSetConstraint)
                                            csc=xPCArch.configSetConstraint(i);
                                            arch.addConfigSetConstraint(csc.paramName,csc.value);
                                        end

                                        ret=arch;



