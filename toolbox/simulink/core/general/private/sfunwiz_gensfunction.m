function sfunwiz_gensfunction( sfunName, IN, timeString, FlagBusUsed, FlagGenHeaderFile, sfunBusHeaderFile, bus_Header_List, slVersion, FlagGenTerminateFunction,  ...
FlagDynSizedInput, FlagDynSizedOutput, idxDynSizedInput, idxDynSizedOutput, fcnProtoTypeUpdate, fcnProtoTypeDerivatives, fcnProtoTypeStart, fcnProtoTypeOutput, fcnProtoTypeTerminate, fcnCallUpdate, fcnCallDerivatives, fcnCallStart, fcnCallOutput, fcnCallTerminate,  ...
NumberOfInputPorts, NumberOfOutputPorts, NumParams, NumDiscStates, NumContStates, NumUserPWorks, sFName, LibrarySourceFiles, InDataTypeMacro, OutDataTypeMacro,  ...
InPortName, InDimsAbs, InDataType, InComplexity, IsInBusBased, InBusName, InDims, directFeed, InIsSigned, InWordLength, FlagInFixPointScaling, InFractionLength, InBias, InSlope,  ...
OutPortName, OutDimsAbs, OutDataType, OutComplexity, IsOutBusBased, OutBusName, OutDims, OutIsSigned, OutWordLength, FlagOutFixPointScaling, OutFractionLength, OutBias, OutSlope,  ...
ParameterName, ParameterDataType, ParameterComplexity, sampleTime, CStatesIC, DStatesIC, PanelIndex, CreateWrapperTLC, ShowCompileSteps, CreateDebugMex, SaveCodeOnly, UseSimStruct, SFunMajorityIndex, businfoStruct, FlagSupportForEach, FlagMultiThread, FlagCodeReuse )






InRow = cellfun( @( x )x( 1 ), InDimsAbs( cellfun( @( x )numel( x ) >= 1, InDimsAbs ) ) );
InCol = ones( size( InDimsAbs ) );
InCol( cellfun( @( x )numel( x ) >= 2, InDimsAbs ) ) = cellfun( @( x )x( 2 ), InDimsAbs( cellfun( @( x )numel( x ) >= 2, InDimsAbs ) ) );
OutRow = cellfun( @( x )x( 1 ), OutDimsAbs( cellfun( @( x )numel( x ) >= 1, OutDimsAbs ) ) );
OutCol = ones( size( OutDimsAbs ) );
OutCol( cellfun( @( x )numel( x ) >= 2, OutDimsAbs ) ) = cellfun( @( x )x( 2 ), OutDimsAbs( cellfun( @( x )numel( x ) >= 2, OutDimsAbs ) ) );
isAllowMoreThan2DDone = false;
NumBuses = numel( find( IsInBusBased ) ) + numel( find( IsOutBusBased ) );
NumInDWork = double( SFunMajorityIndex == 1 ) * numel( find( ~IsInBusBased ) );
NumOutDWork = double( SFunMajorityIndex == 1 ) * numel( find( ~IsOutBusBased ) );
NumParamDWork = double( SFunMajorityIndex == 1 ) * NumParams;
NumTransposeCaches = NumInDWork + NumOutDWork + NumParamDWork;
NumDWork = NumBuses + NumTransposeCaches;

wrapperExternDeclarationStart = sprintf( 'extern %s;\n', fcnProtoTypeStart );
wrapperExternDeclarationUpdate = sprintf( 'extern %s;\n', fcnProtoTypeUpdate );
wrapperExternDeclarationDerivatives = sprintf( 'extern %s;\n', fcnProtoTypeDerivatives );
wrapperExternDeclarationOutput = sprintf( 'extern %s;\n', fcnProtoTypeOutput );
wrapperExternDeclarationTerminate = sprintf( 'extern %s;\n', fcnProtoTypeTerminate );


LibLists = regexprep( LibrarySourceFiles, { ',', '''' }, { ' ', '' } );


InDataTypeDefine = InDataType;
InDataType = cellfun( @( x )regexprep( x, '\w*int64\w*', 'fixpt' ), InDataType, 'UniformOutput', false );
OutDataTypeDefine = OutDataType;
OutDataType = cellfun( @( x )regexprep( x, '\w*int64\w*', 'fixpt' ), OutDataType, 'UniformOutput', false );

IsFixedBeingPropagated = any( strcmp( InDataType, 'fixpt' ) | strcmp( InDataType, 'cfixpt' ) ) ...
 || any( strcmp( OutDataType, 'fixpt' ) | strcmp( OutDataType, 'cfixpt' ) );
IsDataTypeBeyond32Bits = any( InWordLength >= 32 ) || any( OutWordLength >= 32 );

lines = regexp( IN, '\n', 'split' );
clear IN

fileHandler = fopen( sfunName, 'W' );
if ( fileHandler ==  - 1 )
DAStudio.error( 'Simulink:SFunctionBuilder:ErrorOpenForWrite', sfunName );
end 

for lineCell = lines
line = lineCell{ : };

printInfoTag = regexp( line, '^\s*--(\<.+\>)--\s*$', 'tokens', 'once' );

if ( isempty( printInfoTag ) )
fprintf( fileHandler, '%s\n', line );
continue ;
end 

switch printInfoTag{ : }
case 'HeaderCommentInformation'
fprintf( fileHandler,  ...
[ '/*\n' ...
, ' * File: %s\n' ...
, '%s' ...
, ' *\n' ...
, ' * Created: %s\n' ...
, ' */\n' ...
 ], sfunName, genIntro, timeString );
case 'SfunctionName'
fprintf( fileHandler, '#define S_FUNCTION_NAME %s\n', sFName );
case 'Builder Defines'
fprintf( fileHandler,  ...
[ '/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/\n' ...
, '/* %%%%%%-SFUNWIZ_defines_Changes_BEGIN --- EDIT HERE TO _END */\n' ...
 ] );
fprintf( fileHandler, '#define NUM_INPUTS            %d\n', NumberOfInputPorts );
portIdNum = num2cell( 0:NumberOfInputPorts - 1 );
tempCellToPrint = [ portIdNum; ...
portIdNum;InPortName; ...
portIdNum;portDimsArray( InDimsAbs, false ); ...
portIdNum;portDimsArray( InDimsAbs, true ); ...
portIdNum;portwidthToString( InRow ); ...
portIdNum;portwidthToString( InCol ); ...
portIdNum;InDataTypeDefine; ...
portIdNum;InComplexity; ...
portIdNum;num2cell( IsInBusBased ); ...
portIdNum;InBusName; ...
portIdNum;InDims; ...
portIdNum;repmat( { directFeed }, [ 1, NumberOfInputPorts ] ); ...
portIdNum;num2cell( InIsSigned ); ...
portIdNum;num2cell( InWordLength ); ...
portIdNum;num2cell( FlagInFixPointScaling ); ...
portIdNum;num2cell( InFractionLength ); ...
portIdNum;InBias; ...
portIdNum;InSlope ...
 ];
if ( ~isempty( tempCellToPrint ) )
fprintf( fileHandler,  ...
[ '/* Input Port  %d */\n' ...
, '#define IN_PORT_%d_NAME        %s\n' ...
, '#define INPUT_%d_DIMS_ND       {%s}\n' ...
, '#define INPUT_%d_NUM_ELEMS     %s\n' ...
, '#define INPUT_%d_WIDTH         %s\n' ...
, '#define INPUT_DIMS_%d_COL      %s\n' ...
, '#define INPUT_%d_DTYPE         %s\n' ...
, '#define INPUT_%d_COMPLEX       %s\n' ...
, '#define IN_%d_BUS_BASED        %d\n' ...
, '#define IN_%d_BUS_NAME         %s\n' ...
, '#define IN_%d_DIMS             %s\n' ...
, '#define INPUT_%d_FEEDTHROUGH   %d\n' ...
, '#define IN_%d_ISSIGNED         %d\n' ...
, '#define IN_%d_WORDLENGTH       %d\n' ...
, '#define IN_%d_FIXPOINTSCALING  %d\n' ...
, '#define IN_%d_FRACTIONLENGTH   %d\n' ...
, '#define IN_%d_BIAS             %s\n' ...
, '#define IN_%d_SLOPE            %s\n' ...
 ], tempCellToPrint{ : } );
end 
fprintf( fileHandler, '\n#define NUM_OUTPUTS           %d\n', NumberOfOutputPorts );
portIdNum = num2cell( 0:NumberOfOutputPorts - 1 );
tempCellToPrint = [ portIdNum; ...
portIdNum;OutPortName; ...
portIdNum;portDimsArray( OutDimsAbs, false ); ...
portIdNum;portDimsArray( OutDimsAbs, true ); ...
portIdNum;portwidthToString( OutRow ); ...
portIdNum;portwidthToString( OutCol ); ...
portIdNum;OutDataTypeDefine; ...
portIdNum;OutComplexity; ...
portIdNum;num2cell( IsOutBusBased ); ...
portIdNum;OutBusName; ...
portIdNum;OutDims; ...
portIdNum;num2cell( OutIsSigned ); ...
portIdNum;num2cell( OutWordLength ); ...
portIdNum;num2cell( FlagOutFixPointScaling ); ...
portIdNum;num2cell( OutFractionLength ); ...
portIdNum;OutBias; ...
portIdNum;OutSlope ...
 ];
if ( ~isempty( tempCellToPrint ) )
fprintf( fileHandler,  ...
[ '/* Output Port  %d */\n' ...
, '#define OUT_PORT_%d_NAME       %s\n' ...
, '#define OUTPUT_%d_DIMS_ND      {%s}\n' ...
, '#define OUTPUT_%d_NUM_ELEMS    %s\n' ...
, '#define OUTPUT_%d_WIDTH        %s\n' ...
, '#define OUTPUT_DIMS_%d_COL     %s\n' ...
, '#define OUTPUT_%d_DTYPE        %s\n' ...
, '#define OUTPUT_%d_COMPLEX      %s\n' ...
, '#define OUT_%d_BUS_BASED       %d\n' ...
, '#define OUT_%d_BUS_NAME        %s\n' ...
, '#define OUT_%d_DIMS            %s\n' ...
, '#define OUT_%d_ISSIGNED        %d\n' ...
, '#define OUT_%d_WORDLENGTH      %d\n' ...
, '#define OUT_%d_FIXPOINTSCALING %d\n' ...
, '#define OUT_%d_FRACTIONLENGTH  %d\n' ...
, '#define OUT_%d_BIAS            %s\n' ...
, '#define OUT_%d_SLOPE           %s\n' ...
 ], tempCellToPrint{ : } );
end 
fprintf( fileHandler, '\n#define NPARAMS               %d\n', NumParams );
paramIdNum = num2cell( 0:NumParams - 1 );
tempCellToPrint = [ paramIdNum; ...
paramIdNum;ParameterName;
paramIdNum;ParameterDataType; ...
paramIdNum;ParameterComplexity ...
 ];
if ( ~isempty( tempCellToPrint ) )
fprintf( fileHandler,  ...
[ '/* Parameter %d */\n' ...
, '#define PARAMETER_%d_NAME      %s\n' ...
, '#define PARAMETER_%d_DTYPE     %s\n' ...
, '#define PARAMETER_%d_COMPLEX   %s\n' ...
 ], tempCellToPrint{ : } );
end 
tempCellToPrint = { sampleTime, NumDiscStates, DStatesIC, NumContStates, CStatesIC,  ...
CreateWrapperTLC, LibLists, PanelIndex, UseSimStruct, ShowCompileSteps, CreateDebugMex, SaveCodeOnly };
fprintf( fileHandler,  ...
[ '\n' ...
, '#define SAMPLE_TIME_0         %s\n' ...
, '#define NUM_DISC_STATES       %d\n' ...
, '#define DISC_STATES_IC        [%s]\n' ...
, '#define NUM_CONT_STATES       %d\n' ...
, '#define CONT_STATES_IC        [%s]\n' ...
, '\n' ...
, '#define SFUNWIZ_GENERATE_TLC  %d\n' ...
, '#define SOURCEFILES           "%s"\n' ...
, '#define PANELINDEX            %s\n' ...
, '#define USE_SIMSTRUCT         %d\n' ...
, '#define SHOW_COMPILE_STEPS    %d\n' ...
, '#define CREATE_DEBUG_MEXFILE  %d\n' ...
, '#define SAVE_CODE_ONLY        %d\n' ...
, '#define SFUNWIZ_REVISION      3.0\n' ...
 ], tempCellToPrint{ : } );
fprintf( fileHandler,  ...
[ '/* %%%%%%-SFUNWIZ_defines_Changes_END --- EDIT HERE TO _BEGIN */\n' ...
, '/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/\n' ] );
case 'IncludeBusHeader'
if ( FlagBusUsed )
if ( FlagGenHeaderFile )
fprintf( fileHandler, '#include "%s"\n', sfunBusHeaderFile );
else 
fprintf( fileHandler, '%s', bus_Header_List );
end 
isBusDWorkPresent = '( ( ( !ssRTWGenIsCodeGen(S) || isSimulationTarget ) && !ssIsExternalSim(S) ) || ssIsRapidAcceleratorActive(S) )';
fprintf( fileHandler,  ...
[ '/*\n' ...
, ' * Code Generation Environment flag (simulation or standalone target).\n' ...
, ' */\n' ...
, ' static int_T isSimulationTarget;\n' ...
, '/* Utility function prototypes. */\n' ...
, 'static int_T GetRTWEnvironmentMode(SimStruct *S);\n' ...
, '/* Macro used to check if Simulation mode is set to accelerator */\n' ...
, '#define isBusDWorkPresent  %s\n' ...
 ], isBusDWorkPresent );
end 
case 'IncludeFixedPointDotH'
if ( IsFixedBeingPropagated )
fprintf( fileHandler, '#include "fixedpoint.h"\n' );
end 
case 'Parameters Defines'
paramIdNum = 0:NumParams - 1;
if ( ~isempty( paramIdNum ) )
fprintf( fileHandler, '#define PARAM_DEF%d(S) ssGetSFcnParam(S, %d)\n', [ paramIdNum;paramIdNum ] );
end 
fprintf( fileHandler, '%s', writeSFcnBCache( ParameterComplexity, ParameterDataType, ParameterName, FlagBusUsed ) );
for paramType = unique( ParameterDataType )
switch paramType{ : }
case 'real_T'
fprintf( fileHandler,  ...
[ '\n#define IS_PARAM_DOUBLE(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && !mxIsComplex(pVal) && mxIsDouble(pVal))\n' ] );
case 'real32_T'
fprintf( fileHandler,  ...
[ '\n#define IS_PARAM_SINGLE(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && !mxIsComplex(pVal) && mxIsSingle(pVal))\n' ] );
case 'int8_T'
fprintf( fileHandler,  ...
[ '\n#define IS_PARAM_INT8(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && !mxIsComplex(pVal) && mxIsInt8(pVal))\n' ] );
case 'int16_T'
fprintf( fileHandler, [ '\n#define IS_PARAM_INT16(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && !mxIsComplex(pVal) && mxIsInt16(pVal))\n' ] );
case 'int32_T'
fprintf( fileHandler,  ...
[ '\n#define IS_PARAM_INT32(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && !mxIsComplex(pVal) && mxIsInt32(pVal))\n' ] );
case 'uint8_T'
fprintf( fileHandler,  ...
[ '\n#define IS_PARAM_UINT8(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && !mxIsComplex(pVal) && mxIsUint8(pVal))\n' ] );
case 'uint16_T'
fprintf( fileHandler, [ '\n#define IS_PARAM_UINT16(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && !mxIsComplex(pVal) && mxIsUint16(pVal))\n' ] );
case 'uint32_T'
fprintf( fileHandler, [ '\n#define IS_PARAM_UINT32(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && !mxIsComplex(pVal) && mxIsUint32(pVal))\n' ] );
case 'boolean_T'
fprintf( fileHandler,  ...
[ '\n#define IS_PARAM_BOOLEAN(pVal) (mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal))\n' ] );
case 'creal_T'
fprintf( fileHandler,  ...
[ '\n#define IS_PARAM_DOUBLE_CPLX(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && mxIsComplex(pVal) && mxIsDouble(pVal))\n' ] );
case 'creal32_T'
fprintf( fileHandler,  ...
[ '\n#define IS_PARAM_SINGLE_CPLX(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && mxIsComplex(pVal) && mxIsSingle(pVal))\n' ] );
case 'cint8_T'
fprintf( fileHandler,  ...
[ '\n#define IS_PARAM_INT8_CPLX(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && mxIsComplex(pVal) && mxIsInt8(pVal))\n' ] );
case 'cint16_T'
fprintf( fileHandler,  ...
[ '\n#define IS_PARAM_INT16_CPLX(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && mxIsComplex(pVal) && mxIsInt16(pVal))\n' ] );
case 'cint32_T'
fprintf( fileHandler,  ...
[ '\n#define IS_PARAM_INT32_CPLX(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && mxIsComplex(pVal) && mxIsInt32(pVal))\n' ] );
case 'cuint8_T'
fprintf( fileHandler,  ...
[ '\n#define IS_PARAM_UINT8_CPLX(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && mxIsComplex(pVal) && mxIsUint8(pVal))\n' ] );
case 'cuint16_T'
fprintf( fileHandler,  ...
[ '\n#define IS_PARAM_UINT16_CPLX(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && mxIsComplex(pVal) && mxIsUint16(pVal))\n' ] );
case 'cuint32_T'
fprintf( fileHandler,  ...
[ '\n#define IS_PARAM_UINT32_CPLX(pVal) (mxIsNumeric(pVal) && !mxIsLogical(pVal) &&\\' ...
, '\n!mxIsEmpty(pVal) && !mxIsSparse(pVal) && mxIsComplex(pVal) && mxIsUint32(pVal))\n' ] );
end 
end 

case 'ExternDeclarationStart'
fprintf( fileHandler, '%s', wrapperExternDeclarationStart );
case 'ExternDeclarationOutputs'
fprintf( fileHandler, '%s', wrapperExternDeclarationOutput );
case 'ExternDeclarationUpdates'
if ( NumDiscStates > 0 )
fprintf( fileHandler, '%s', wrapperExternDeclarationUpdate );
end 
case 'ExternDeclarationDerivatives'
if ( NumContStates > 0 )
fprintf( fileHandler, '%s', wrapperExternDeclarationDerivatives );
end 
case 'ExternDeclarationTerminate'
fprintf( fileHandler, '%s', wrapperExternDeclarationTerminate );
case 'MDL_CHECK_PARAMETERS'
if ( NumParams > 0 )
method = get_mdlCheckParameters_method( NumParams, ParameterName, ParameterComplexity, ParameterDataType, sampleTime, FlagBusUsed );
fprintf( fileHandler, '%s', method );
end 
case 'SpecifySimStateCompliance'
if ( NumUserPWorks == 0 )
opSetting = 'USE_DEFAULT_OPERATING_POINT';


else 
opSetting = 'DISALLOW_OPERATING_POINT';
end 
fprintf( fileHandler,  ...
'    ssSetOperatingPointCompliance(S, %s);\n', opSetting );
case 'ParametersDeclaration'
if ( NumberOfInputPorts > 0 )
fprintf( fileHandler,  ...
'    DECL_AND_INIT_DIMSINFO(inputDimsInfo);\n' );
end 
fprintf( fileHandler,  ...
'    DECL_AND_INIT_DIMSINFO(outputDimsInfo);\n' );
parameterDeclaration = get_parameters_declaration( NumParams );
fprintf( fileHandler, '%s', parameterDeclaration );
case 'ssSetCodeGenArrayLayout'
if ( slfeature( 'RowMajorDimensionSupport' ) == 1 )
if ( SFunMajorityIndex == 1 )
fprintf( fileHandler,  ...
'    ssSetArrayLayoutForCodeGen(S, SS_ROW_MAJOR);\n' );

elseif ( SFunMajorityIndex == 0 )
fprintf( fileHandler,  ...
'    ssSetArrayLayoutForCodeGen(S, SS_COLUMN_MAJOR);\n' );
else 
fprintf( fileHandler,  ...
'    ssSetArrayLayoutForCodeGen(S, SS_ALL);\n' );
end 
end 
case 'ssSetNumContStates'
fprintf( fileHandler,  ...
'    ssSetNumContStates(S, NUM_CONT_STATES);\n' );
case 'ssSetNumDiscStates'
fprintf( fileHandler,  ...
'    ssSetNumDiscStates(S, NUM_DISC_STATES);\n' );
case 'ssFxpSetU32BitRegionCompliantInfo'
if ( IsFixedBeingPropagated && IsDataTypeBeyond32Bits )
fprintf( fileHandler,  ...
'    ssFxpSetU32BitRegionCompliant(S, 1);\n' );

end 
case 'ssSetNumInputPortsInfo'
fprintf( fileHandler,  ...
'    if (!ssSetNumInputPorts(S, NUM_INPUTS)) return;\n' );
case 'ssSetInputPortInformation'
for i = 1:NumberOfInputPorts
i0 = i - 1;
fprintf( fileHandler,  ...
'    /* Input Port %d */\n', i0 );
if ( IsInBusBased( i ) )
[ busStr, isAllowMoreThan2DDone ] = genBusString( InBusName, OutBusName, i, true, InDimsAbs{ i }, OutDimsAbs, InDims{ i }, OutDims, isAllowMoreThan2DDone );
fprintf( fileHandler, '%s', busStr );
else 
if ~all( InDimsAbs{ i } == 1 ) && numel( InDimsAbs{ i } ) > 1
if ~isAllowMoreThan2DDone
fprintf( fileHandler, '    ssAllowSignalsWithMoreThan2D(S);\n' );
isAllowMoreThan2DDone = true;
end 
fprintf( fileHandler, '    inputDimsInfo.numDims = %d;\n', numel( InDimsAbs{ i } ) );
fprintf( fileHandler, '    inputDimsInfo.width = INPUT_%d_NUM_ELEMS;\n', i0 );
fprintf( fileHandler, '    int_T in%dDims[] = INPUT_%d_DIMS_ND;\n', i0, i0 );
fprintf( fileHandler, '    inputDimsInfo.dims = in%dDims;\n', i0 );
fprintf( fileHandler, '    ssSetInputPortDimensionInfo(S, %d, &inputDimsInfo);\n', i0 );
else 


fprintf( fileHandler,  ...
'    ssSetInputPortWidth(S, %d, INPUT_%d_NUM_ELEMS);\n', i0, i0 );
end 
if ( strcmp( InDataType{ i }, 'fixpt' ) || strcmp( InDataType{ i }, 'cfixpt' ) )

fprintf( fileHandler, 'if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY)\n' );
if contains( InDataTypeDefine{ i }, 'int64' )

registerFixedPointDataTypeForInt64( fileHandler, InDataTypeMacro{ i }, i0, true );
else 
registerFixedPointDataType( fileHandler, InDataTypeMacro{ i }, i0, FlagInFixPointScaling( i ), true );
end 
fprintf( fileHandler, '    ssSetInputPortDataType(S, %d, %s_%d);\n }\n', i0, InDataTypeMacro{ i }, i0 );
else 
fprintf( fileHandler, '    ssSetInputPortDataType(S, %d, %s);\n', i0, InDataTypeMacro{ i } );
end 
fprintf( fileHandler, '    ssSetInputPortComplexSignal(S, %d, INPUT_%d_COMPLEX);\n', i0, i0 );

fprintf( fileHandler, '    ssSetInputPortDirectFeedThrough(S, %d, INPUT_%d_FEEDTHROUGH);\n', i0, i0 );
fprintf( fileHandler, '    ssSetInputPortRequiredContiguous(S, %d, 1); /*direct input signal access*/\n', i0 );
fprintf( fileHandler, '\n' );
end 
end 
case 'ssSetInputPortDirectFeedThroughInfo'

case 'ssSetNumOutputPortsInfo'
fprintf( fileHandler, '    if (!ssSetNumOutputPorts(S, NUM_OUTPUTS)) return;\n' );
case 'ssSetOutputPortInformation'
for i = 1:NumberOfOutputPorts
i0 = i - 1;
fprintf( fileHandler, '    /* Output Port %d */\n', i0 );
if ( IsOutBusBased( i ) )
[ busStr, isAllowMoreThan2DDone ] = genBusString( InBusName, OutBusName, i, false, InDimsAbs, OutDimsAbs{ i }, InDims, OutDims{ i }, isAllowMoreThan2DDone );
fprintf( fileHandler, '%s', busStr );
else 
if ( numel( OutDimsAbs{ i } ) > 1 && any( OutDimsAbs{ i }( 2:end  ) > 1 ) ) ||  ...
( strcmp( OutDims{ i }, 'N-D' ) || strcmp( OutDims{ i }, '2-D' ) )

if ~isAllowMoreThan2DDone
fprintf( fileHandler, '    ssAllowSignalsWithMoreThan2D(S);\n' );
isAllowMoreThan2DDone = true;
end 

fprintf( fileHandler, '    outputDimsInfo.numDims = %d;\n', numel( OutDimsAbs{ i } ) );
fprintf( fileHandler, '    outputDimsInfo.width = OUTPUT_%d_NUM_ELEMS;\n', i0 );
fprintf( fileHandler, '    int_T out%dDims[] = OUTPUT_%d_DIMS_ND;\n', i0, i0 );
fprintf( fileHandler, '    outputDimsInfo.dims = out%dDims;\n', i0 );
fprintf( fileHandler, '    ssSetOutputPortDimensionInfo(S, %d, &outputDimsInfo);\n', i0 );
else 
fprintf( fileHandler, '    ssSetOutputPortWidth(S, %d, OUTPUT_%d_NUM_ELEMS);\n', i0, i0 );
end 
if ( strcmp( OutDataType{ i }, 'fixpt' ) || strcmp( OutDataType{ i }, 'cfixpt' ) )
fprintf( fileHandler, 'if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY)\n' );
if contains( OutDataTypeDefine{ i }, 'int64' )
registerFixedPointDataTypeForInt64( fileHandler, OutDataTypeMacro{ i }, i0, false );
else 
registerFixedPointDataType( fileHandler, OutDataTypeMacro{ i }, i0, FlagOutFixPointScaling( i ), false );
end 
fprintf( fileHandler, '    ssSetOutputPortDataType(S, %d, %s_%d);\n }\n', i0, OutDataTypeMacro{ i }, i0 );
else 
fprintf( fileHandler, '    ssSetOutputPortDataType(S, %d, %s);\n', i0, OutDataTypeMacro{ i } );
end 
fprintf( fileHandler, '    ssSetOutputPortComplexSignal(S, %d, OUTPUT_%d_COMPLEX);\n', i0, i0 );
end 
end 
case 'ssSetDWorkInformation'
if ( FlagBusUsed )
setNumDWork = sprintf( [ '\n    if (ssRTWGenIsCodeGen(S)) {\n' ...
, '        isSimulationTarget = GetRTWEnvironmentMode(S);\n' ...
, '        if (isSimulationTarget == -1) {\n' ...
, '            ssSetLocalErrorStatus(S, " Unable to determine a valid code generation environment mode");\n' ...
, '            return;\n' ...
, '        }\n' ...
, '        isSimulationTarget |= ssRTWGenIsModelReferenceSimTarget(S);\n' ...
, '    }\n' ...
, '    \n' ...
, '    /* Set the number of dworks */\n' ...
, '    if (!ssSetNumDWork(S, %d)) return;\n' ...
 ], NumDWork );
else 
setNumDWork = sprintf( '    if (!ssSetNumDWork(S, %d)) return;\n', NumTransposeCaches );
end 
paramsIdx = num2cell( 0:NumParams - 1 );

BusDWorkInit = '';

InBusDWorkName = cellfun( @( x )sprintf( '%sBUS', x ), InPortName( IsInBusBased ), 'UniformOutput', false );
OutBusDWorkName = cellfun( @( x )sprintf( '%sBUS', x ), OutPortName( IsOutBusBased ), 'UniformOutput', false );
busDWorkIdxMap = containers.Map(  );
if FlagBusUsed
tempCellToPrint = [ num2cell( ( 0:NumBuses - 1 ) + NumTransposeCaches ); ...
[ InBusDWorkName, OutBusDWorkName ]; ...
[ InBusName( IsInBusBased ), OutBusName( IsOutBusBased ) ]; ...
num2cell( ( 0:NumBuses - 1 ) + NumTransposeCaches ); ...
num2cell( ( 0:NumBuses - 1 ) + NumTransposeCaches ); ...
num2cell( ( 0:NumBuses - 1 ) + NumTransposeCaches ); ...
num2cell( ( 0:NumBuses - 1 ) + NumTransposeCaches ); ...
[ InBusDWorkName, OutBusDWorkName ]; ...
num2cell( ( 0:NumBuses - 1 ) + NumTransposeCaches ); ...
num2cell( ( 0:NumBuses - 1 ) + NumTransposeCaches ) ...
 ];
idx = tempCellToPrint{ 1 };
if ~isempty( tempCellToPrint )

for i = 1:length( InBusDWorkName )
busDWorkIdxMap( InBusDWorkName{ i } ) = idx;
idx = idx + 1;
end 
for i = 1:length( OutBusDWorkName )
busDWorkIdxMap( OutBusDWorkName{ i } ) = idx;
idx = idx + 1;
end 

end 
if ( ~isempty( tempCellToPrint ) )
BusDWorkInit = sprintf( [ '\n' ...
, '      /*\n' ...
, '       * Configure the dwork %d (%s)\n' ...
, '       */\n' ...
, '#if defined(MATLAB_MEX_FILE)\n' ...
, '      if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\n' ...
, '        DTypeId dataTypeIdReg;\n' ...
, '        ssRegisterTypeFromNamedObject(S, "%s", &dataTypeIdReg);\n' ...
, '        if (dataTypeIdReg == INVALID_DTYPE_ID) return;\n' ...
, '        if (isBusDWorkPresent){\n' ...
, '           ssSetDWorkDataType(S, %d, dataTypeIdReg);\n' ...
, '        }else{\n' ...
, '           ssSetDWorkDataType(S, %d, SS_POINTER);\n' ...
, '        }\n' ...
, '      }\n' ...
, '#endif\n' ...
, '      \n' ...
, '      ssSetDWorkUsageType(S, %d, SS_DWORK_USED_AS_DWORK);\n' ...
, '      ssSetDWorkName(S, %d, "%s");\n' ...
, '      ssSetDWorkWidth(S, %d, DYNAMICALLY_SIZED);\n' ...
, '      ssSetDWorkComplexSignal(S, %d, COMPLEX_NO);\n' ...
 ], tempCellToPrint{ : } );
end 

else 
tempCellToPrint = [ num2cell( ( 0:NumBuses - 1 ) + NumTransposeCaches ); ...
[ InBusDWorkName, OutBusDWorkName ]; ...
[ InBusName( IsInBusBased ), OutBusName( IsOutBusBased ) ]; ...
num2cell( ( 0:NumBuses - 1 ) + NumTransposeCaches ); ...
num2cell( ( 0:NumBuses - 1 ) + NumTransposeCaches ); ...
num2cell( ( 0:NumBuses - 1 ) + NumTransposeCaches ); ...
[ InBusDWorkName, OutBusDWorkName ]; ...
num2cell( ( 0:NumBuses - 1 ) + NumTransposeCaches ); ...
num2cell( ( 0:NumBuses - 1 ) + NumTransposeCaches ) ...
 ];

if ( ~isempty( tempCellToPrint ) )
BusDWorkInit = sprintf( [ '\n' ...
, '      /*\n' ...
, '       * Configure the dwork %d (%s)\n' ...
, '       */\n' ...
, '#if defined(MATLAB_MEX_FILE)\n' ...
, '      if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\n' ...
, '        DTypeId dataTypeIdReg;\n' ...
, '        ssRegisterTypeFromNamedObject(S, "%s", &dataTypeIdReg);\n' ...
, '        if (dataTypeIdReg == INVALID_DTYPE_ID) return;\n' ...
, '        ssSetDWorkDataType(S, %d, dataTypeIdReg);\n' ...
, '      }\n' ...
, '#endif\n' ...
, '      \n' ...
, '      ssSetDWorkUsageType(S, %d, SS_DWORK_USED_AS_DWORK);\n' ...
, '      ssSetDWorkName(S, %d, "%s");\n' ...
, '      ssSetDWorkWidth(S, %d, DYNAMICALLY_SIZED);\n' ...
, '      ssSetDWorkComplexSignal(S, %d, COMPLEX_NO);\n' ...
 ], tempCellToPrint{ : } );
end 

end 

inPortsIdx = num2cell( 0:NumberOfInputPorts - 1 );
outPortsIdx = num2cell( 0:NumberOfOutputPorts - 1 );

TransposeCacheDWorkInit = '';
InTransposeCacheDWorkName = cellfun( @( x )[ x, '_t' ], InPortName( SFunMajorityIndex == 1 & ~IsInBusBased ), 'UniformOutput', false );
OutTransposeCacheDWorkName = cellfun( @( x )[ x, '_t' ], OutPortName( SFunMajorityIndex == 1 & ~IsOutBusBased ), 'UniformOutput', false );
ParamTransposeCacheDWorkName = cellfun( @( x )[ x, '_t' ], ParameterName( SFunMajorityIndex == 1 & true( [ 1, NumParams ] ) ), 'UniformOutput', false );
QuerryInputDataTypeDummyPlaceholder = cell( [ 1, numel( find( SFunMajorityIndex == 1 & ~IsInBusBased ) ) ] );
QuerryOutputDataTypeDummyPlaceholder = cell( [ 1, numel( find( SFunMajorityIndex == 1 & ~IsOutBusBased ) ) ] );
QuerryParamDataType = cellfun( @( x )sprintf( '      DTypeId paramDTypeId_%d;\n      ssGetSFcnParamDataType(S, %d, &paramDTypeId_%d);\n', x, x, x ), paramsIdx( SFunMajorityIndex == 1 & true( [ 1, NumParams ] ) ), 'UniformOutput', false );
InTransposeCacheDataType = cellfun( @( x )sprintf( 'ssGetInputPortDataType(S, %d)', x ), inPortsIdx( SFunMajorityIndex == 1 & ~IsInBusBased ), 'UniformOutput', false );
OutTransposeCacheDataType = cellfun( @( x )sprintf( 'ssGetOutputPortDataType(S, %d)', x ), outPortsIdx( SFunMajorityIndex == 1 & ~IsOutBusBased ), 'UniformOutput', false );
ParamTransposeCacheDataType = cellfun( @( x )sprintf( 'paramDTypeId_%d', x ), paramsIdx( SFunMajorityIndex == 1 & true( [ 1, NumParams ] ) ), 'UniformOutput', false );
InTransposeCacheWidth = cellfun( @( x )sprintf( 'ssGetInputPortWidth(S, %d)', x ), inPortsIdx( SFunMajorityIndex == 1 & ~IsInBusBased ), 'UniformOutput', false );
OutTransposeCacheWidth = cellfun( @( x )sprintf( 'ssGetOutputPortWidth(S, %d)', x ), outPortsIdx( SFunMajorityIndex == 1 & ~IsOutBusBased ), 'UniformOutput', false );
ParamTransposeCacheWidth = cellfun( @( x )sprintf( 'mxGetNumberOfElements(PARAM_DEF%d(S))', x ), paramsIdx( SFunMajorityIndex == 1 & true( [ 1, NumParams ] ) ), 'UniformOutput', false );
tempCellToPrint = [ num2cell( 0:NumTransposeCaches - 1 ); ...
[ InTransposeCacheDWorkName, OutTransposeCacheDWorkName, ParamTransposeCacheDWorkName ]; ...
[ QuerryInputDataTypeDummyPlaceholder, QuerryOutputDataTypeDummyPlaceholder, QuerryParamDataType ]; ...
num2cell( 0:NumTransposeCaches - 1 ); ...
[ InTransposeCacheDataType, OutTransposeCacheDataType, ParamTransposeCacheDataType ]; ...
num2cell( 0:NumTransposeCaches - 1 ); ...
num2cell( 0:NumTransposeCaches - 1 ); ...
[ InTransposeCacheDWorkName, OutTransposeCacheDWorkName, ParamTransposeCacheDWorkName ]; ...
num2cell( 0:NumTransposeCaches - 1 ); ...
[ InTransposeCacheWidth, OutTransposeCacheWidth, ParamTransposeCacheWidth ]; ...
num2cell( 0:NumTransposeCaches - 1 ); ...
[ InComplexity( SFunMajorityIndex == 1 & ~IsInBusBased ), OutComplexity( SFunMajorityIndex == 1 & ~IsOutBusBased ), ParameterComplexity( SFunMajorityIndex == 1 & true( [ 1, NumParams ] ) ) ] ...
 ];

if ( ~isempty( tempCellToPrint ) )
TransposeCacheDWorkInit = sprintf( [ '\n' ...
, '    /*\n' ...
, '     * Configure the dwork %d (%s)\n' ...
, '     */\n' ...
, '%s' ...
, '    ssSetDWorkDataType(S, %d, %s);\n' ...
, '    ssSetDWorkUsageType(S, %d, SS_DWORK_USED_AS_SCRATCH);\n' ...
, '    ssSetDWorkName(S, %d, "%s");\n' ...
, '    ssSetDWorkWidth(S, %d, %s);\n' ...
, '    ssSetDWorkComplexSignal(S, %d, %s);\n' ...
 ], tempCellToPrint{ : } );
end 


if ( FlagBusUsed || SFunMajorityIndex == 1 )
fprintf( fileHandler, '%s', setNumDWork );
end 
if ( SFunMajorityIndex == 1 )
fprintf( fileHandler, '%s', TransposeCacheDWorkInit );
end 
if ( FlagBusUsed )
fprintf( fileHandler, '%s',  ...
[ newline ...
, BusDWorkInit ...
 ] );
end 

case 'ssSetPWorkInformation'
fprintf( fileHandler, '    ssSetNumPWork(S, %d);\n', NumUserPWorks );
case 'PWorkAccessDeclaration'
if ( NumUserPWorks > 0 )
fprintf( fileHandler, '    void **pW = ssGetPWork(S);\n' );
end 
case 'ssSetSimulinkVersionGeneratedIn'
fprintf( fileHandler, '    ssSetSimulinkVersionGeneratedIn(S, "%s");\n', slVersion );
case 'ssSetOptions'
opts = "SS_OPTION_EXCEPTION_FREE_CODE";


if ( SFunMajorityIndex ~= 1 )
if ( CreateWrapperTLC )
opts( end  + 1 ) = "SS_OPTION_USE_TLC_WITH_ACCELERATOR";%#ok
end 
opts( end  + 1 ) = "SS_OPTION_WORKS_WITH_CODE_REUSE";%#ok
end 

if ( FlagCodeReuse && ~any( opts( : ) == "SS_OPTION_WORKS_WITH_CODE_REUSE" ) )
opts( end  + 1 ) = "SS_OPTION_WORKS_WITH_CODE_REUSE";
end 
if ( numel( opts ) > 1 )
opts = "(" + join( opts, [ ' |', newline, '                     ' ] ) + ")";
end 
fprintf( fileHandler, '    ssSetOptions(S, %s);\n', opts );
case 'ssSetForEachInformation'
if FlagSupportForEach
fprintf( fileHandler, '    ssSupportsMultipleExecInstances(S, true);\n' );
end 
case 'ssSetRuntimeThread'
if FlagMultiThread
fprintf( fileHandler, '    ssSetRuntimeThreadSafetyCompliance(S, RUNTIME_THREAD_SAFETY_COMPLIANCE_TRUE);\n' );
end 
case 'MDL_SET_PORTS_DIMENSION_INFO'
DimsInfoMOne_One = getBodyDimsInfoWidthMdlPortWidthNonFrame( InDimsAbs, OutDimsAbs );
fprintf( fileHandler, '%s\n', DimsInfoMOne_One );

case 'MDL_SET_DWORK_WIDTHS'
if ( FlagBusUsed || NumParams > 0 )
mdlDWorkWidth1 = sprintf( [ '\n#define MDL_SET_WORK_WIDTHS\n' ...
, '#if defined(MDL_SET_WORK_WIDTHS) && defined(MATLAB_MEX_FILE)\n' ...
, '\n' ...
, 'static void mdlSetWorkWidths(SimStruct *S)\n' ...
, '{\n' ...
 ] );
if ( FlagBusUsed )
mdlDWorkWidth1 = [ mdlDWorkWidth1 ...
, sprintf( [ '/* Set the width of DWork(s) used for marshalling the IOs */\n' ...
, '    if (isBusDWorkPresent) {\n' ...
 ] ) ...
 ];%#ok
end 

mdlDWorkWidth2 = '';
dworkCount = NumTransposeCaches;
for i = 1:NumberOfInputPorts
i0 = i - 1;
if ( IsInBusBased( i ) )
mdlDWorkWidth2 = [ mdlDWorkWidth2 ...
, sprintf( '\n        /* Update dwork %d */\n', dworkCount ) ...
, sprintf( '        ssSetDWorkWidth(S, %d, ssGetInputPortWidth(S, %d));\n', dworkCount, i0 ) ...
 ];%#ok
dworkCount = dworkCount + 1;
end 
end 
for i = 1:NumberOfOutputPorts
i0 = i - 1;
if ( IsOutBusBased( i ) )
mdlDWorkWidth2 = [ mdlDWorkWidth2 ...
, sprintf( '\n        /* Update dwork %d */\n', dworkCount ) ...
, sprintf( '        ssSetDWorkWidth(S, %d, ssGetOutputPortWidth(S, %d));\n', dworkCount, i0 ) ...
 ];%#ok
dworkCount = dworkCount + 1;
end 
end 

mdlDWorkWidth3 = '';
if ( FlagBusUsed )
mdlDWorkWidth3 = [ mdlDWorkWidth3, sprintf( '\n    }\n' ) ];%#ok
end 


if ( ~UseSimStruct && NumParams > 0 )
if ( FlagBusUsed )
mdlDWorkWidth3 = [ mdlDWorkWidth3, sprintf( '\n    {\n' ) ];%#ok
end 

mdlDWorkWidth3 = [ mdlDWorkWidth3, sprintf( '\n    const char_T *rtParamNames[] = {' ) ];%#ok
mdlDWorkWidth3 = [ mdlDWorkWidth3, sprintf( '"P%d",', 1:NumParams ) ];%#ok
mdlDWorkWidth3( end  ) = [  ];

mdlDWorkWidth3 = [ mdlDWorkWidth3 ...
, sprintf( [ '};\n' ...
, '    ssRegAllTunableParamsAsRunTimeParams(S, rtParamNames);\n' ...
 ] ) ...
 ];%#ok
if ( FlagBusUsed )
mdlDWorkWidth3 = [ mdlDWorkWidth3, sprintf( '\n    }' ) ];%#ok
end 
end 
mdlDWorkWidth3 = [ mdlDWorkWidth3 ...
, sprintf( [ '\n' ...
, '}\n' ...
, '\n#endif\n' ...
 ] ) ...
 ];%#ok

fprintf( fileHandler, '%s', mdlDWorkWidth1 );
fprintf( fileHandler, '%s', mdlDWorkWidth2 );
fprintf( fileHandler, '%s', mdlDWorkWidth3 );
end 
case 'ssSetSampleTimeInfo'
if ( any( strcmp( ParameterName, sampleTime ) ) )
paramIdNum = 0:NumParams - 1;
fprintf( fileHandler, '    ssSetSampleTime(S, 0, *mxGetPr(ssGetSFcnParam(S, %d)));\n', paramIdNum( strcmp( ParameterName, sampleTime ) ) );
else 
fprintf( fileHandler, '    ssSetSampleTime(S, 0, SAMPLE_TIME_0);\n' );
end 
fprintf( fileHandler, '    ssSetModelReferenceSampleTimeDefaultInheritance(S);\n' );
case 'MDL_INITIALIZE_CONDITIONS'
if ( NumDiscStates > 0 || NumContStates > 0 )
methodInit = get_mdlInitializeConditions_method( NumDiscStates, DStatesIC, NumContStates, CStatesIC, NumParams, ParameterComplexity, ParameterDataType, ParameterName );
fprintf( fileHandler, '%s', methodInit );
end 
case 'BusDataDeclaration'
if ( FlagBusUsed )
[ businfoStruct, busDecl, busTerminationCode ] = genDataDeclarationForBus( SFunMajorityIndex, businfoStruct, InDimsAbs, OutDimsAbs, InPortName, OutPortName, IsInBusBased, IsOutBusBased, busDWorkIdxMap );
fprintf( fileHandler, '%s', busDecl );
end 
case 'mdlStartFunctionCall'
complexParameterDeclaration = writeParamsDeclaration_cmplx( NumParams, ParameterComplexity, ParameterDataType, ParameterName );
declareParamTranspose = '';
dataCopyParamTranspose = '';
if ( SFunMajorityIndex == 1 )
declareParamTranspose = getDeclarationOfTempParams( NumParams, ParameterName, ParameterDataType, NumInDWork + NumOutDWork );
dataCopyParamTranspose = getTransposedParametersToTemp( NumParams, ParameterName, ParameterDataType );
end 

fprintf( fileHandler, [  ...
'%s',  ...
'%s',  ...
'%s',  ...
'%s\n' ],  ...
complexParameterDeclaration,  ...
declareParamTranspose,  ...
dataCopyParamTranspose,  ...
[ '    ', fcnCallStart ] );
case 'MDL_SET_PORTS_DATA_TYPE'
portMethods = genPortDataTypeMethods( NumberOfInputPorts );
fprintf( fileHandler, '%s', portMethods );
case 'InputDataTypeDeclaration'
printDataTypeDeclaration( fileHandler, NumberOfInputPorts, InPortName, InDataType, InWordLength, InIsSigned, IsInBusBased, 'In', InBusName );
case 'OutputDataTypeDeclaration'
printDataTypeDeclaration( fileHandler, NumberOfOutputPorts, OutPortName, OutDataType, OutWordLength, OutIsSigned, IsOutBusBased, 'Out', OutBusName );
case 'DiscStatesDeclarationConst'
if ( NumDiscStates > 0 )
fprintf( fileHandler, '    const real_T *xD = ssGetDiscStates(S);\n' );
end 
case 'ContStatesDeclarationConst'
if ( NumContStates > 0 )
fprintf( fileHandler, '    const real_T *xC = ssGetContStates(S);\n' );
end 
case 'ParameterDeclarationStart'
fprintf( fileHandler, '%s', writeParamsDeclaration( NumParams, ParameterComplexity, ParameterDataType, ParameterName, ~FlagBusUsed ) );
case 'ParameterDeclarationConst'
fprintf( fileHandler, '%s', writeParamsDeclaration( NumParams, ParameterComplexity, ParameterDataType, ParameterName ) );
case 'PortWidthDeclarationConst'
if ( FlagDynSizedOutput )
fprintf( fileHandler, sprintf( [ '    const int_T y_%d_width = ssGetOutputPortWidth(S, 0);\n' ], idxDynSizedOutput( : ) - 1 ) );
end 
if ( FlagDynSizedInput && directFeed )
fprintf( fileHandler, sprintf( [ '    const int_T u_%d_width = ssGetInputPortWidth(S, 0);\n' ], idxDynSizedInput( : ) - 1 ) );
end 
case 'mdlOutputFunctionCall'
complexParameterDeclaration = writeParamsDeclaration_cmplx( NumParams, ParameterComplexity, ParameterDataType, ParameterName );
transposeCodeForNonBusData = getTransposeCodeForNonBusTypeData( NumberOfInputPorts, InPortName, InDataType, InWordLength, IsInBusBased, InIsSigned,  ...
NumberOfOutputPorts, OutPortName, OutDataType, OutWordLength, IsOutBusBased, OutIsSigned, NumInDWork,  ...
NumParams, ParameterName, ParameterDataType, NumOutDWork, SFunMajorityIndex, directFeed, true );
if ( FlagBusUsed )
OutputBusFcn = genFunctionForBus( InDimsAbs, OutDimsAbs, fcnCallOutput, InPortName, OutPortName, complexParameterDeclaration, SFunMajorityIndex, transposeCodeForNonBusData, businfoStruct, IsInBusBased, IsOutBusBased, busDWorkIdxMap );
fprintf( fileHandler, '%s', OutputBusFcn );
else 
fprintf( fileHandler, '%s', complexParameterDeclaration );
if ( SFunMajorityIndex == 1 )
fprintf( fileHandler,  ...
[ '%s',  ...
'%s',  ...
'%s',  ...
'%s',  ...
'\n',  ...
'%s',  ...
'%s',  ...
'%s',  ...
'\n',  ...
'%s' ],  ...
transposeCodeForNonBusData.commentDataTranspose,  ...
transposeCodeForNonBusData.declareInputTranspose,  ...
transposeCodeForNonBusData.declareOutputTranspose,  ...
transposeCodeForNonBusData.declareParamTranspose,  ...
 ...
transposeCodeForNonBusData.dataCopyInputTranspose,  ...
transposeCodeForNonBusData.dataCopyParamTranspose,  ...
[ '    ', fcnCallOutput ],  ...
 ...
transposeCodeForNonBusData.dataCopyOutputTranspose );
else 
fprintf( fileHandler, '    %s\n', fcnCallOutput );
end 
end 
case 'DiscStatesDeclaration'
if ( NumDiscStates > 0 )
fprintf( fileHandler, '    real_T *xD = ssGetDiscStates(S);\n' );
end 
case 'mdlUpdateFunctionCall'
complexParameterDeclaration = writeParamsDeclaration_cmplx( NumParams, ParameterComplexity, ParameterDataType, ParameterName );
transposeCodeForNonBusData = getTransposeCodeForNonBusTypeData( NumberOfInputPorts, InPortName, InDataType, InWordLength, IsInBusBased, InIsSigned,  ...
NumberOfOutputPorts, OutPortName, OutDataType, OutWordLength, IsOutBusBased, OutIsSigned, NumInDWork,  ...
NumParams, ParameterName, ParameterDataType, NumOutDWork, SFunMajorityIndex, directFeed, false );
if ( FlagBusUsed )
UpdateBusFcn = genFunctionForBus( InDimsAbs, OutDimsAbs, fcnCallUpdate, InPortName, OutPortName, complexParameterDeclaration, SFunMajorityIndex, transposeCodeForNonBusData, businfoStruct, IsInBusBased, IsOutBusBased, busDWorkIdxMap );
fprintf( fileHandler, '%s', UpdateBusFcn );
else 
fprintf( fileHandler, '%s', complexParameterDeclaration );
if ( SFunMajorityIndex == 1 )
fprintf( fileHandler,  ...
[ '%s',  ...
'%s',  ...
'%s',  ...
'%s',  ...
'\n',  ...
'%s',  ...
'%s',  ...
'%s',  ...
'\n',  ...
'%s' ],  ...
transposeCodeForNonBusData.commentDataTranspose,  ...
transposeCodeForNonBusData.declareInputTranspose,  ...
transposeCodeForNonBusData.declareOutputTranspose,  ...
transposeCodeForNonBusData.declareParamTranspose,  ...
 ...
transposeCodeForNonBusData.dataCopyInputTranspose,  ...
transposeCodeForNonBusData.dataCopyParamTranspose,  ...
[ '    ', fcnCallUpdate ],  ...
 ...
transposeCodeForNonBusData.dataCopyOutputTranspose );
else 
fprintf( fileHandler, '    %s\n', fcnCallUpdate );
end 
end 
case 'dxVarDeclaration'
if ( NumContStates > 0 )
fprintf( fileHandler, '    real_T *dx = ssGetdX(S);\n' );
end 
case 'ContStatesDeclaration'
if ( NumContStates > 0 )
fprintf( fileHandler, '    real_T *xC = ssGetContStates(S);\n' );
end 
case 'mdlDerivativesFunctionCall'
complexParameterDeclaration = writeParamsDeclaration_cmplx( NumParams, ParameterComplexity, ParameterDataType, ParameterName );
transposeCodeForNonBusData = getTransposeCodeForNonBusTypeData( NumberOfInputPorts, InPortName, InDataType, InWordLength, IsInBusBased, InIsSigned,  ...
NumberOfOutputPorts, OutPortName, OutDataType, OutWordLength, IsOutBusBased, OutIsSigned, NumInDWork,  ...
NumParams, ParameterName, ParameterDataType, NumOutDWork, SFunMajorityIndex, directFeed, false );
if ( FlagBusUsed )
DerivativeBusFcn = genFunctionForBus( InDimsAbs, OutDimsAbs, fcnCallDerivatives, InPortName, OutPortName, complexParameterDeclaration, SFunMajorityIndex, transposeCodeForNonBusData, businfoStruct, IsInBusBased, IsOutBusBased, busDWorkIdxMap );
fprintf( fileHandler, '%s', DerivativeBusFcn );
else 
fprintf( fileHandler, '%s', complexParameterDeclaration );
if ( SFunMajorityIndex == 1 )
fprintf( fileHandler,  ...
[ '%s',  ...
'%s',  ...
'%s',  ...
'%s',  ...
'\n',  ...
'%s',  ...
'%s',  ...
'%s',  ...
'\n',  ...
'%s' ],  ...
transposeCodeForNonBusData.commentDataTranspose,  ...
transposeCodeForNonBusData.declareInputTranspose,  ...
transposeCodeForNonBusData.declareOutputTranspose,  ...
transposeCodeForNonBusData.declareParamTranspose,  ...
 ...
transposeCodeForNonBusData.dataCopyInputTranspose,  ...
transposeCodeForNonBusData.dataCopyParamTranspose,  ...
[ '    ', fcnCallDerivatives ],  ...
 ...
transposeCodeForNonBusData.dataCopyOutputTranspose );
else 
fprintf( fileHandler, '    %s\n', fcnCallDerivatives );
end 
end 
case 'mdlTerminateDeclaration'
if ( any( strcmp( ParameterComplexity, 'COMPLEX_YES' ) ) )
if ( ~FlagGenTerminateFunction )
fprintf( fileHandler, '    SFcnBCache *c = (SFcnBCache *) ssGetUserData(S);\n' );
end 
fprintf( fileHandler,  ...
[ '    if (c != NULL) {\n' ...
, '        /* Free complex parameter information */\n' ...
 ] );
paramsCmplx = ParameterName( strcmp( ParameterComplexity, 'COMPLEX_YES' ) );
fprintf( fileHandler, '        free(c->%s);\n', paramsCmplx{ : } );
if ( FlagBusUsed )
fprintf( fileHandler,  ...
[ '        /* Free bus information */\n' ...
, '        free(c->busInfo);' ...
 ] );
end 
fprintf( fileHandler,  ...
[ '        free(c);\n' ...
, '    }\n' ...
, '    ssSetUserData(S, NULL);\n' ...
 ] );
else 
if ( FlagBusUsed )
fprintf( fileHandler,  ...
[ '    /* Free stored bus information */\n' ...
, '    busInfoStruct *busInfo = (busInfoStruct *) ssGetUserData(S);\n' ...
, '    if(busInfo != NULL) {\n' ...
, '        free(busInfo);\n' ...
, '    }\n' ...
 ] );
fprintf( fileHandler, busTerminationCode );
end 
end 
case 'mdlTerminateFunctionCall'
complexParameterDeclaration = writeParamsDeclaration_cmplx( NumParams, ParameterComplexity, ParameterDataType, ParameterName );
declareParamTranspose = '';
dataCopyParamTranspose = '';
if ( SFunMajorityIndex == 1 )
declareParamTranspose = getDeclarationOfTempParams( NumParams, ParameterName, ParameterDataType, NumInDWork + NumOutDWork );
dataCopyParamTranspose = getTransposedParametersToTemp( NumParams, ParameterName, ParameterDataType );
end 

fprintf( fileHandler, [  ...
'%s',  ...
'%s',  ...
'%s',  ...
'%s\n' ],  ...
complexParameterDeclaration,  ...
declareParamTranspose,  ...
dataCopyParamTranspose,  ...
[ '    ', fcnCallTerminate ] );
case 'GetRTWEnvironmentMode'
if ( FlagBusUsed )
GetRTWStaticFunctionStr = [  ...
'static int_T GetRTWEnvironmentMode(SimStruct *S)', ( newline ) ...
, '{', ( newline ) ...
, '    int_T status = -1;', ( newline ) ...
, '    mxArray *plhs[1];', ( newline ) ...
, '    mxArray *prhs[1];', ( newline ) ...
, '    mxArray * err;', ( newline ) ...
, '    ', ( newline ) ...
, '    /*', ( newline ) ...
, '     * Get the name of the Simulink block diagram', ( newline ) ...
, '     */', ( newline ) ...
, '    prhs[0] = mxCreateString(ssGetBlockDiagramName(S));', ( newline ) ...
, '    plhs[0] = NULL;', ( newline ) ...
, '    ', ( newline ) ...
, '    /*', ( newline ) ...
, '     * Call "isSimulationTarget = rtwenvironmentmode(modelName)" in MATLAB', ( newline ) ...
, '     */', ( newline ) ...
, '    err = mexCallMATLABWithTrap(1, plhs, 1, prhs, "rtwenvironmentmode");', ( newline ) ...
, '    mxDestroyArray(prhs[0]);', ( newline ) ...
, '    ', ( newline ) ...
, '    /*', ( newline ) ...
, '     * Set the error status if an error occurred', ( newline ) ...
, '     */', ( newline ) ...
, '    if (err) {', ( newline ) ...
, '        if (plhs[0]) {', ( newline ) ...
, '            mxDestroyArray(plhs[0]);', ( newline ) ...
, '            plhs[0] = NULL;', ( newline ) ...
, '        }', ( newline ) ...
, '        ssSetLocalErrorStatus(S, "Unknown error during call to ''rtwenvironmentmode''.");', ( newline ) ...
, '        return -1;', ( newline ) ...
, '    }', ( newline ) ...
, '    ', ( newline ) ...
, '    /*', ( newline ) ...
, '     * Get the value returned by rtwenvironmentmode(modelName)', ( newline ) ...
, '    */', ( newline ) ...
, '    if (plhs[0]) {', ( newline ) ...
, '        status = (int_T) (mxGetScalar(plhs[0]) != 0);', ( newline ) ...
, '        mxDestroyArray(plhs[0]);', ( newline ) ...
, '        plhs[0] = NULL;', ( newline ) ...
, '    }', ( newline ) ...
, '    ', ( newline ) ...
, '    return (status);', ( newline ) ...
, '}', ( newline ) ...
 ];
fprintf( fileHandler, '%s', GetRTWStaticFunctionStr );
end 
case 'IncludeFixedPointDotC'
if ( IsFixedBeingPropagated )
fprintf( fileHandler, '#include "fixedpoint.c"\n' );
end 
end 
end 

fclose( fileHandler );

end 

function isMatrix = isAnyInputSignalAMatrixSignal( InCol, InRow )
isMatrix = any( InCol > 1 & InRow > 1 );
end 

function declaredNumParams = get_parameters_declaration( NumParams )
if ( NumParams > 0 )
declaredNumParams = [ '    ssSetNumSFcnParams(S, NPARAMS); /* Number of expected parameters */', ( newline ) ...
, '    #if defined(MATLAB_MEX_FILE)', ( newline ) ...
, '    if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {', ( newline ) ...
, '        mdlCheckParameters(S);', ( newline ) ...
, '        if (ssGetErrorStatus(S) != NULL) {', ( newline ) ...
, '            return;', ( newline ) ...
, '        }', ( newline ) ...
, '    } else {', ( newline ) ...
, '        return; /* Parameter mismatch will be reported by Simulink */', ( newline ) ...
, '    }', ( newline ) ...
, '    #endif', ( newline ) ...
 ];
else 
declaredNumParams = [ '    ssSetNumSFcnParams(S, NPARAMS);', ( newline ) ...
, '    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {', ( newline ) ...
, '        return; /* Parameter mismatch will be reported by Simulink */', ( newline ) ...
, '    }', ( newline ) ...
 ];
end 
end 

function body = get_mdlCheckParameters_method( NumParams, ParameterName, ParameterComplexity, ParameterDataType, sampleTime, FlagBusUsed )
checkparams = '';
for i = 1:NumParams
i0 = i - 1;
if ( strcmp( ParameterName{ i }, sampleTime ) )
ErrorStringParam = sprintf( 'Sample time parameter %s must be of type double', ParameterName{ i } );
checkparams = [ checkparams, sprintf( '\n    {\n' ) ...
, sprintf( '        const mxArray *pVal%d = ssGetSFcnParam(S, %d);\n', i0, i0 ) ...
, sprintf( '        if (!mxIsDouble(pVal%d)) {\n', i0 ) ...
, sprintf( '            ssSetLocalErrorStatus(S, "%s");\n', ErrorStringParam ) ...
, sprintf( '            return;\n' ) ...
, sprintf( '        }\n' ) ...
, sprintf( '    }\n' ) ...
 ];%#ok

end 

keySet = { 'real_T', 'creal_T', 'real32_T', 'creal32_T', 'int8_T', 'cint8_T', 'int16_T', 'cint16_T', 'int32_T', 'cint32_T', 'uint8_T', 'cuint8_T', 'uint16_T', 'cuint16_T', 'uint32_T', 'cuint32_T', 'boolean_T' };
valSet = { 'DOUBLE', 'DOUBLE_CPLX', 'SINGLE', 'SINGLE_CPLX', 'INT8', 'INT8_CPLX', 'INT16', 'INT16_CPLX', 'INT32', 'INT32_CPLX', 'UINT8', 'UINT8_CPLX', 'UINT16', 'UINT16_CPLX', 'UINT32', 'UINT32_CPLX', 'BOOLEAN' };
macroFcnSuffixLUT = containers.Map( keySet, valSet );

suffixMacroFcn = macroFcnSuffixLUT( ParameterDataType{ i } );

checkparams = [ checkparams, sprintf( '\n    {\n' ) ...
, sprintf( '        const mxArray *pVal%d = ssGetSFcnParam(S, %d);\n', i0, i0 ) ...
, sprintf( '        if (!IS_PARAM_%s(pVal%d)) {\n', suffixMacroFcn, i0 ) ...
, sprintf( '            invalidParam = true;\n' ) ...
, sprintf( '            paramIndex = %d;\n', i0 ) ...
, sprintf( '            goto EXIT_POINT;\n' ) ...
, sprintf( '        }\n' ) ...
, sprintf( '    }\n' ) ...
 ];%#ok
end 

initSfcnCache = '';
mskCmplx = strcmp( ParameterComplexity, 'COMPLEX_YES' );
if ( any( mskCmplx ) )
initSfcnCache = sprintf( '    {\n' );
paramsIdNum = num2cell( 0:NumParams - 1 );
tempCellToPrint = [ ParameterDataType( mskCmplx );ParameterName( mskCmplx );ParameterDataType( mskCmplx );paramsIdNum( mskCmplx );ParameterDataType( mskCmplx ) ];
initSfcnCache = [ initSfcnCache, sprintf( '        %s *%s = (%s *)malloc(mxGetNumberOfElements(PARAM_DEF%d(S))*sizeof(%s));\n', tempCellToPrint{ : } ) ];
initSfcnCache = [ initSfcnCache, sprintf( '        SFcnBCache *c = (SFcnBCache *)ssGetUserData(S);\n' ) ];
initSfcnCache = [ initSfcnCache, sprintf( '        if (c != NULL) {\n' ) ...
, sprintf( '            free(c->%s);\n', ParameterName{ mskCmplx } ) ...
 ];
if ( FlagBusUsed )
initSfcnCache = [ initSfcnCache, sprintf( '            free(c->busInfo);\n' ) ];
end 
initSfcnCache = [ initSfcnCache ...
, sprintf( [ '            free(c);\n' ...
, '            ssSetUserData(S, NULL);\n' ...
, '        }\n' ...
 ] ) ...
 ];
initSfcnCache = [ initSfcnCache ...
, sprintf( [ '        c = (SFcnBCache *) calloc(1, sizeof(SFcnBCache));\n' ...
, '        if (c == NULL) {\n' ...
, '            ssSetLocalErrorStatus(S, "Memory allocation failed");\n' ...
, '            goto EXIT_POINT;\n' ...
, '        }\n' ...
 ] ) ...
 ];
tempCellToPrint = [ ParameterName( mskCmplx );ParameterName( mskCmplx ) ];
initSfcnCache = [ initSfcnCache, sprintf( '        c->%s = %s;\n', tempCellToPrint{ : } ) ];
initSfcnCache = [ initSfcnCache, sprintf( '        ssSetUserData(S, c);\n' ) ];
initSfcnCache = [ initSfcnCache, sprintf( '    }\n' ) ];
end 

body = [ '#define MDL_CHECK_PARAMETERS', ( newline ) ...
, '#if defined(MDL_CHECK_PARAMETERS) && defined(MATLAB_MEX_FILE)', ( newline ) ...
, '/* Function: mdlCheckParameters =============================================', ( newline ) ...
, ' * Abstract:', ( newline ) ...
, ' *     Verify parameter definitions and types.', ( newline ) ...
, ' */', ( newline ) ...
, 'static void mdlCheckParameters(SimStruct *S)', ( newline ) ...
, '{', ( newline ) ...
, '    int paramIndex  = 0;', ( newline ) ...
, '    bool invalidParam = false;', ( newline ) ...
, '    /* All parameters must match the S-function Builder Dialog */', ( newline ) ...
, checkparams, '', ( newline ) ...
, initSfcnCache, '', ( newline ) ...
, '    EXIT_POINT:', ( newline ) ...
, '    if (invalidParam) {', ( newline ) ...
, '        static char parameterErrorMsg[1024];', ( newline ) ...
, '        sprintf(parameterErrorMsg, "The data type and or complexity of parameter %d does not match the "', ( newline ) ...
, '                "information specified in the S-function Builder dialog. "', ( newline ) ...
, '                "For non-double parameters you will need to cast them using int8, int16, "', ( newline ) ...
, '                "int32, uint8, uint16, uint32 or boolean.", paramIndex + 1);', ( newline ) ...
, '        ssSetLocalErrorStatus(S, parameterErrorMsg);', ( newline ) ...
, '    }', ( newline ) ...
, '    return;', ( newline ) ...
, '}', ( newline ) ...
, '#endif /* MDL_CHECK_PARAMETERS */', ( newline ) ...
 ];

end 

function [ busString, isAllowMoreThan2DDone ] = genBusString( InBusName, OutBusName, busIdx, FlagIn, InDimsAbs, OutDimsAbs, InDims, OutDims, isAllowMoreThan2DDone )
i0 = busIdx - 1;
if ~isAllowMoreThan2DDone
ssAllowMoreThan2DStr = 'ssAllowSignalsWithMoreThan2D(S);';
isAllowMoreThan2DDone = true;
else 
ssAllowMoreThan2DStr = '';
end 

if ( FlagIn )

if ~all( InDimsAbs == 1 ) && numel( InDimsAbs ) > 1
dimsStuff = [ ( newline ) ...
, sprintf( '    %s\n', ssAllowMoreThan2DStr ) ...
, sprintf( '    inputDimsInfo.numDims = %d;\n', numel( InDimsAbs ) ) ...
, sprintf( '    inputDimsInfo.width = INPUT_%d_NUM_ELEMS;\n', i0 ) ...
, sprintf( '    int_T inBus%dDims[] = INPUT_%d_DIMS_ND;\n', i0, i0 ) ...
, sprintf( '    inputDimsInfo.dims = inBus%dDims;\n', i0 ) ...
, sprintf( '    ssSetInputPortDimensionInfo(S, %d, &inputDimsInfo);\n', i0 ) ...
 ];
else 
dimsStuff = sprintf( '    ssSetInputPortWidth(S, %d, INPUT_%d_NUM_ELEMS);\n', i0, i0 );
end 
busString = [ ( newline ) ...
, sprintf( '  /* Register %s datatype for Input port %d */\n', InBusName{ busIdx }, i0 ) ...
, ( newline ) ...
, '    #if defined(MATLAB_MEX_FILE)', ( newline ) ...
, '    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY)', ( newline ) ...
, '    {', ( newline ) ...
, '      DTypeId dataTypeIdReg;', ( newline ) ...
, sprintf( '      ssRegisterTypeFromNamedObject(S, "%s", &dataTypeIdReg);\n', InBusName{ busIdx } ) ...
, '      if(dataTypeIdReg == INVALID_DTYPE_ID) return;', ( newline ) ...
, sprintf( '      ssSetInputPortDataType(S, %d, dataTypeIdReg);\n', i0 ) ...
, '    }', ( newline ) ...
, '    #endif', ( newline ) ...
, sprintf( '%s', dimsStuff ) ...
, sprintf( '    ssSetInputPortComplexSignal(S, %d, INPUT_%d_COMPLEX);\n', i0, i0 ) ...
, sprintf( '    ssSetInputPortDirectFeedThrough(S, %d, INPUT_%d_FEEDTHROUGH);\n', i0, i0 ) ...
, sprintf( '    ssSetInputPortRequiredContiguous(S, %d, 1); /*direct input signal access*/\n', i0 ) ...
, sprintf( '    ssSetBusInputAsStruct(S, %d, IN_%d_BUS_BASED);\n', i0, i0 ) ...
, sprintf( '    ssSetInputPortBusMode(S, %d, SL_BUS_MODE);\n', i0 ) ...
 ];

else 
if numel( OutDimsAbs ) > 1 && any( OutDimsAbs( 2:end  ) > 1 ) ||  ...
( strcmp( OutDims, 'N-D' ) || strcmp( OutDims, '2-D' ) )
dimsStuff = [  ...
sprintf( '    %s\n', ssAllowMoreThan2DStr ) ...
, sprintf( '    outputDimsInfo.numDims = %d;\n', numel( OutDimsAbs ) ) ...
, sprintf( '    outputDimsInfo.width = OUTPUT_%d_NUM_ELEMS;\n', i0 ) ...
, sprintf( '    int_T outBus%dDims[] = OUTPUT_%d_DIMS_ND;\n', i0, i0 ) ...
, sprintf( '    outputDimsInfo.dims = outBus%dDims;\n', i0 ) ...
, sprintf( '    ssSetOutputPortDimensionInfo(S, %d, &outputDimsInfo);\n', i0 ) ...
 ];
else 
dimsStuff = sprintf( '    ssSetOutputPortWidth(S, %d, OUTPUT_%d_NUM_ELEMS);\n', i0, i0 );
end 
busString = [ ( newline ) ...
, sprintf( '  /* Register %s datatype for Output port %d */\n', OutBusName{ busIdx }, i0 ) ...
, ( newline ) ...
, '    #if defined(MATLAB_MEX_FILE)', ( newline ) ...
, '    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY)', ( newline ) ...
, '    {', ( newline ) ...
, '      DTypeId dataTypeIdReg;', ( newline ) ...
, sprintf( '      ssRegisterTypeFromNamedObject(S, "%s", &dataTypeIdReg);\n', OutBusName{ busIdx } ) ...
, '      if(dataTypeIdReg == INVALID_DTYPE_ID) return;', ( newline ) ...
, sprintf( '        ssSetOutputPortDataType(S, %d, dataTypeIdReg);\n', i0 ) ...
, '    }', ( newline ) ...
, '    #endif', ( newline ) ...
, ( newline ) ...
, sprintf( '%s', dimsStuff ) ...
, sprintf( '    ssSetBusOutputObjectName(S, %d, (void *) "%s");\n', i0, OutBusName{ busIdx } ) ...
, sprintf( '    ssSetOutputPortComplexSignal(S, %d, OUTPUT_%d_COMPLEX);\n', i0, i0 ) ...
, sprintf( '    ssSetBusOutputAsStruct(S, %d,OUT_%d_BUS_BASED);\n', i0, i0 ) ...
, sprintf( '    ssSetOutputPortBusMode(S, %d, SL_BUS_MODE);\n', i0 ) ...
 ];
end 
end 

function mdlInitCondition = get_mdlInitializeConditions_method( NumDStates, dIC, NumCStates, cIC, NumParams, ParameterComplexity, ParameterDataType, ParameterName )
vectordIC = regexp( strtrim( dIC ), '\s*,\s*', 'split' );
vectorcIC = regexp( strtrim( cIC ), '\s*,\s*', 'split' );

paramIdNum = num2cell( 0:NumParams - 1 );
mskParamIsDouble = strcmp( ParameterComplexity, 'COMPLEX_NO' ) & strcmp( ParameterDataType, 'real_T' );
paramStrToMatchSingleton = cellfun( @( x )[ '^\s*', x, '\s*$' ], ParameterName, 'UniformOutput', false );
paramStrToMatchAny = cellfun( @( x )[ '\<', x, '\>' ], ParameterName, 'UniformOutput', false );
paramDataStrSingleton = cellfun( @( x )sprintf( '*mxGetPr(ssGetSFcnParam(S, %d))', x ), paramIdNum, 'UniformOutput', false );
paramDataStrParenthesized = cellfun( @( x )sprintf( '(*mxGetPr(ssGetSFcnParam(S, %d)))', x ), paramIdNum, 'UniformOutput', false );
warningComment = '';
if ( any( ~mskParamIsDouble ) )
warningComment = sprintf( '\n    /* Warning: parameters not of type double used as IC will be replaced with 0.0 */\n' );
end 

initD = '';
declareDInitC = '';
if ( NumDStates > 0 )
declareDInitC = sprintf( '    real_T *xD = ssGetRealDiscStates(S);\n' );

vectordIC = regexprep( vectordIC, paramStrToMatchSingleton( mskParamIsDouble ), paramDataStrSingleton( mskParamIsDouble ) );
vectordIC = regexprep( vectordIC, paramStrToMatchAny( mskParamIsDouble ), paramDataStrParenthesized( mskParamIsDouble ) );
vectordIC = regexprep( vectordIC, paramStrToMatchAny( ~mskParamIsDouble ), '0.0' );

stateIdNum = num2cell( 0:NumDStates - 1 );
tempCellToPrint = [ stateIdNum;vectordIC ];
initD = [ ( newline ) ...
, sprintf( '    xD[%d] = %s;\n', tempCellToPrint{ : } ) ...
 ];
end 

initC = '';
declareCInitC = '';

if ( NumCStates > 0 )
declareCInitC = sprintf( '    real_T *xC = ssGetContStates(S);\n' );

vectorcIC = regexprep( vectorcIC, paramStrToMatchSingleton( mskParamIsDouble ), paramDataStrSingleton( mskParamIsDouble ) );
vectorcIC = regexprep( vectorcIC, paramStrToMatchAny( mskParamIsDouble ), paramDataStrParenthesized( mskParamIsDouble ) );
vectorcIC = regexprep( vectorcIC, paramStrToMatchAny( ~mskParamIsDouble ), '0.0' );

stateIdNum = num2cell( 0:NumCStates - 1 );
tempCellToPrint = [ stateIdNum;vectorcIC ];
initC = [ ( newline ) ...
, sprintf( '    xC[%d] = %s;\n', tempCellToPrint{ : } ) ...
 ];
end 

mdlInitCondition = [ '#define MDL_INITIALIZE_CONDITIONS', ( newline ) ...
, '/* Function: mdlInitializeConditions ========================================', ( newline ) ...
, ' * Abstract:', ( newline ) ...
, ' *    Initialize the states', ( newline ) ...
, ' */', ( newline ) ...
, 'static void mdlInitializeConditions(SimStruct *S)', ( newline ) ...
, '{', ( newline ) ...
, declareDInitC ...
, declareCInitC ...
, warningComment ...
, initD ...
, initC ...
, '}', ( newline ) ...
 ];

end 

function intro = genIntro(  )
intro = [ ' *', ( newline ) ...
, ' *', ( newline ) ...
, ' *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---', ( newline ) ...
, ' *', ( newline ) ...
, ' *   This file is an S-function produced by the S-Function', ( newline ) ...
, ' *   Builder which only recognizes certain fields.  Changes made', ( newline ) ...
, ' *   outside these fields will be lost the next time the block is', ( newline ) ...
, ' *   used to load, edit, and resave this file. This file will be overwritten', ( newline ) ...
, ' *   by the S-function Builder block. If you want to edit this file by hand, ', ( newline ) ...
, ' *   you must change it only in the area defined as:  ', ( newline ) ...
, ' *', ( newline ) ...
, ' *        %%%-SFUNWIZ_defines_Changes_BEGIN', ( newline ) ...
, ' *        #define NAME ''replacement text'' ', ( newline ) ...
, ' *        %%% SFUNWIZ_defines_Changes_END', ( newline ) ...
, ' *', ( newline ) ...
, ' *   DO NOT change NAME--Change the ''replacement text'' only.', ( newline ) ...
, ' *', ( newline ) ...
, ' *   For better compatibility with the Simulink Coder, the', ( newline ) ...
, ' *   "wrapper" S-function technique is used.  This is discussed', ( newline ) ...
, ' *   in the Simulink Coder''s Manual in the Chapter titled,', ( newline ) ...
, ' *   "Wrapper S-functions".', ( newline ) ...
, ' *', ( newline ) ...
, ' *  -------------------------------------------------------------------------', ( newline ) ...
, ' * | See matlabroot/simulink/src/sfuntmpl_doc.c for a more detailed template |', ( newline ) ...
, ' *  ------------------------------------------------------------------------- ', ( newline ) ...
 ];
end 


function body = getBodyDimsInfoWidthMdlPortWidthNonFrame( InDimsAbs, OutDimsAbs )

idxInputArray = cellfun( @( x )find( x > 1 ), InDimsAbs, 'UniformOutput', false );
idxInputArray = find( ~cellfun( @isempty, idxInputArray ) );

idxInputDynArray = cellfun( @( x )find( x ==  - 1 ), InDimsAbs, 'UniformOutput', false );
idxInputDynArray = find( ~cellfun( @isempty, idxInputDynArray ) );

idxOutputArray = cellfun( @( x )find( x > 1 ), OutDimsAbs, 'UniformOutput', false );
idxOutputArray = find( ~cellfun( @isempty, idxOutputArray ) );

idxOutputDynArray = cellfun( @( x )find( x ==  - 1 ), OutDimsAbs, 'UniformOutput', false );
idxOutputDynArray = find( ~cellfun( @isempty, idxOutputDynArray ) );


DimsInfoBody = [ '#if defined(MATLAB_MEX_FILE)', ( newline ) ...
, '#define MDL_SET_INPUT_PORT_DIMENSION_INFO', ( newline ) ...
, 'static void mdlSetInputPortDimensionInfo(SimStruct        *S, ', ( newline ) ...
, '                                         int_T            port,', ( newline ) ...
, '                                         const DimsInfo_T *dimsInfo)', ( newline ) ...
, '{', ( newline ) ...
, '    if(!ssSetInputPortDimensionInfo(S, port, dimsInfo)) return;', ( newline ) ...
, '}', ( newline ) ...
, '#endif', ( newline ) ...
, ( newline ) ...
, '#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO', ( newline ) ...
, '#if defined(MDL_SET_OUTPUT_PORT_DIMENSION_INFO)', ( newline ) ...
, 'static void mdlSetOutputPortDimensionInfo(SimStruct        *S, ', ( newline ) ...
, '                                          int_T            port, ', ( newline ) ...
, '                                          const DimsInfo_T *dimsInfo)', ( newline ) ...
, '{', ( newline ) ...
, '    if (!ssSetOutputPortDimensionInfo(S, port, dimsInfo)) return;', ( newline ) ...
, '}', ( newline ) ...
, '#endif', ( newline ) ...
 ];

defaultDimsInfoStart = sprintf( [ '#define MDL_SET_DEFAULT_PORT_DIMENSION_INFO\n' ...
, 'static void mdlSetDefaultPortDimensionInfo(SimStruct *S)\n' ...
, '{\n' ...
, '   DECL_AND_INIT_DIMSINFO(portDimsInfo);\n' ...
, '	int_T dims[2];\n' ...
 ] );
defaultDimsInfoEnd = sprintf( [ '    return;\n' ...
, '}\n' ...
 ] );
defaultDimsInfoBody = '';


for i = 1:numel( idxInputArray )
idx = idxInputArray( i );
if any( idxInputDynArray == idx ) || any( idxOutputDynArray == idx )

continue 
end 
i0 = idx - 1;
defaultDimsInfoBody = sprintf( [ '%s' ...
, '	\n/* Setting default dimensions for input port %d */\n' ...
, '	portDimsInfo.width = INPUT_%d_NUM_ELEMS;\n' ...
, '	dims[0] = INPUT_%d_NUM_ELEMS;\n' ...
, '	dims[1] = 1;\n' ...
, '	portDimsInfo.numDims = 2;\n' ...
, '   if (ssGetInputPortWidth(S, %d) == DYNAMICALLY_SIZED) {  \n' ...
, '       ssSetInputPortMatrixDimensions(S, %d, 1 , 1);\n' ...
, '   }\n' ...
 ], defaultDimsInfoBody, i0, i0, i0, i0, i0 );
end 


for i = 1:numel( idxOutputArray )
idx = idxOutputArray( i );
if any( idxOutputDynArray == idx ) || any( idxInputDynArray == idx )

continue 
end 
i0 = idx - 1;
defaultDimsInfoBody = sprintf( [ '%s' ...
, '	\n/* Setting default dimensions for output port %d */\n' ...
, '	portDimsInfo.width = OUTPUT_%d_NUM_ELEMS;\n' ...
, '   dims[0]              = OUTPUT_%d_NUM_ELEMS;\n' ...
, '   dims[1]              = 1;\n' ...
, '	portDimsInfo.numDims = 2;\n' ...
, '   if (ssGetOutputPortNumDimensions(S, %d) == (-1)) {  \n' ...
, '       ssSetOutputPortDimensionInfo(S, %d, &portDimsInfo);\n' ...
, '   }\n' ...
 ], defaultDimsInfoBody, i0, i0, i0, i0, i0 );

end 

if ~isempty( defaultDimsInfoBody )
defaultDimsInfo = [ defaultDimsInfoStart, defaultDimsInfoBody, defaultDimsInfoEnd ];
else 
defaultDimsInfo = '';
end 

body = [ DimsInfoBody, defaultDimsInfo ];

end 

function bodyToPrint = genFunctionForBus( InDimsAbs, OutDimsAbs, fcnCallStr, InPortName, OutPortName, complexParameterDeclaration, SFunMajorityIdx, codeNonBus, businfoStruct, isInBusBased, isOutBusBased, busDWorkIdxMap )

busDeclarationStr = sprintf( '\n\t/* Temporary bus copy declarations */\n' );

if ( businfoStruct( end  ).complex_param_flag )
bus_access_str = sprintf( '\tbusInfoStruct* busInfo = c->busInfo;\n' );
else 
bus_access_str = sprintf( '\tbusInfoStruct* busInfo = (busInfoStruct *) ssGetUserData(S);\n' );
end 

DataTypeNames = sfbGetBuiltinDataTypeNames(  );
inputIdx = 1;
outputIdx = 1;
stuffToPrintIn = sprintf( [ '\n\t/*Copy from Simulink to bus structure*/\n' ] );
stuffToPrintOut = sprintf( [ '\n\t/*Copy from bus structure to Simulink*/\n' ] );
widthStr = 'topLevel';
model = businfoStruct( end  ).model;
idxInputBuses = find( isInBusBased == 1 );
idxOutputBuses = find( isOutBusBased == 1 );
isParentArray = false;

for i = 1:length( businfoStruct )
isInput = businfoStruct( i ).isinput_port;

if isInput

busName = businfoStruct( i ).bus_structure( 1 ).Name;
offsetList = { '0' };
level = 0;
isCplx = 0;
dimsVec = InDimsAbs{ idxInputBuses( inputIdx ) };
width = prod( dimsVec );
isNd = any( dimsVec( 2:end  ) > 1 );
tempBusName = sprintf( '_%sBUS', InPortName{ idxInputBuses( inputIdx ) } );
if isequal( prod( width ), 1 ) && ~businfoStruct( i ).bus_structure( 1 ).isNestedBusArray
busDeclarationStr = sprintf( [ '%s\t %s %s;\n' ], busDeclarationStr, busName, tempBusName );
else 
if ~isempty( busDWorkIdxMap ) && busDWorkIdxMap.isKey( tempBusName( 2:end  ) )
busDeclarationStr = sprintf( [ '%s\t %s* %s = *(%s**)ssGetDWork(S,%d);\n' ], busDeclarationStr, busName, tempBusName, busName, busDWorkIdxMap( tempBusName( 2:end  ) ) );
else 
busDeclarationStr = sprintf( [ '%s\t %s %s[%d];\n' ], busDeclarationStr, busName, tempBusName, width );
end 
end 

dst = sprintf( [ '(%s)' ], tempBusName );
srcAddr = sprintf( [ '(char *) %s' ], InPortName{ idxInputBuses( inputIdx ) } );
stuffToPrintIn = sprintf( [ '%s\n\t/*Copy from Simulink to %s for Input port %d*/' ], stuffToPrintIn, tempBusName, idxInputBuses( inputIdx ) - 1 );
currBusPortInfoCIdx = businfoStruct( i ).portInfoCIdx;
stuffToPrint = SLStructMarshalToUserStruct( busName, width, isNd, widthStr, dst, srcAddr, offsetList, level, isCplx, businfoStruct( end  ).busVisitedMap,  ...
model, SFunMajorityIdx, DataTypeNames, idxInputBuses( inputIdx ) - 1, isParentArray, currBusPortInfoCIdx );
stuffToPrintIn = sprintf( [ '%s \n%s' ], stuffToPrintIn, stuffToPrint );
inputIdx = inputIdx + 1;
end 
end 


widthStr = 'topLevel';
for i = 1:length( businfoStruct )
isOutput = ~businfoStruct( i ).isinput_port;

if isOutput
busName = businfoStruct( i ).bus_structure( 1 ).Name;
offsetList = { '0' };
level = 0;
isCplx = 0;
dimsVec = OutDimsAbs{ idxOutputBuses( outputIdx ) };
width = prod( dimsVec );
isNd = any( dimsVec( 2:end  ) > 1 );
tempBusName = sprintf( '_%sBUS', OutPortName{ idxOutputBuses( outputIdx ) } );

if isequal( prod( width ), 1 ) && ~businfoStruct( i ).bus_structure( 1 ).isNestedBusArray
busDeclarationStr = sprintf( [ '%s\t %s %s;\n' ], busDeclarationStr, busName, tempBusName );
else 
if ~isempty( busDWorkIdxMap ) && busDWorkIdxMap.isKey( tempBusName( 2:end  ) )
busDeclarationStr = sprintf( [ '%s\t %s* %s = *(%s**)ssGetDWork(S,%d);\n' ], busDeclarationStr, busName, tempBusName, busName, busDWorkIdxMap( tempBusName( 2:end  ) ) );
else 
busDeclarationStr = sprintf( [ '%s\t %s %s[%d];\n' ], busDeclarationStr, busName, tempBusName, width );
end 
end 

srcAddr = sprintf( [ '(%s)' ], tempBusName );
dst = sprintf( [ '(char *) %s' ], OutPortName{ idxOutputBuses( outputIdx ) } );
stuffToPrintOut = sprintf( [ '%s\n\t/*Copy from %s to Simulink for Output port %d*/\n' ], stuffToPrintOut, tempBusName, idxOutputBuses( outputIdx ) - 1 );
currBusPortInfoCIdx = businfoStruct( i ).portInfoCIdx;
stuffToPrint = UserStructMarshalToSLStruct( busName, width, isNd, widthStr, dst, srcAddr, offsetList, level, isCplx, businfoStruct( end  ).busVisitedMap,  ...
model, SFunMajorityIdx, DataTypeNames, idxOutputBuses( outputIdx ) - 1, isParentArray, currBusPortInfoCIdx );
stuffToPrintOut = sprintf( [ '%s \n%s' ], stuffToPrintOut, stuffToPrint );
outputIdx = outputIdx + 1;
end 
end 




body = sprintf( '\n\tslDataTypeAccess *dta = ssGetDataTypeAccess(S);\n' );
body = sprintf( [ '%s\tconst char *bpath = ssGetPath(S);\n' ], body );
body = sprintf( [ '%s\n%s\n' ], body, stuffToPrintIn );


body = sprintf( [ '%s\n\t%s\n\n' ], body, fcnCallStr );

body = sprintf( [ '%s\t%s\n' ], body, stuffToPrintOut );

bodyToPrint = [ bus_access_str,  ...
codeNonBus.commentDataTranspose,  ...
codeNonBus.declareInputTranspose,  ...
codeNonBus.declareOutputTranspose,  ...
codeNonBus.declareParamTranspose,  ...
busDeclarationStr,  ...
complexParameterDeclaration,  ...
codeNonBus.dataCopyInputTranspose,  ...
codeNonBus.dataCopyParamTranspose,  ...
body,  ...
codeNonBus.dataCopyOutputTranspose ];


end 



function [ businfoStruct, busDataDecl, terminationCode ] = genDataDeclarationForBus( SFunMajorityIdx, businfoStruct, InDimsAbs, OutDimsAbs, InPortName, OutPortName, isInBusBased, isOutBusBased, busDWorkIdxMap )



terminationCode = sprintf( [ '\n\tif (!isBusDWorkPresent) {\n' ] );
bus_access_str = '';
startMethodsForBus1 = sprintf( [ '    /* Bus Information */\n' ...
, '    slDataTypeAccess *dta = ssGetDataTypeAccess(S);\n' ...
, '    const char *bpath = ssGetPath(S);\n' ...
 ] );
malloc_check_str = sprintf( [ '\tif(busInfo==NULL) {\n' ...
, '        ssSetLocalErrorStatus(S, "Memory allocation failure");\n' ...
, '        return;\n' ...
, '    }\n' ...
, '\n' ...
 ] );

if ( businfoStruct( end  ).complex_param_flag )
bus_access_str = sprintf( '\tSFcnBCache *c = (SFcnBCache *)ssGetUserData(S);\n' );
bus_access_str1 = sprintf( '\tc->busInfo = busInfo;\n' );
else 
bus_access_str1 = sprintf( '\tssSetUserData(S, busInfo);\n' );
end 

[ businfoStruct, busPortSizeDecl, orderingMap, offsetStorageStr, getDataTypeId ] = getOffsets( businfoStruct, SFunMajorityIdx, InDimsAbs, OutDimsAbs, isInBusBased, isOutBusBased );

busDataDecl = [ startMethodsForBus1, getDataTypeId, offsetStorageStr, bus_access_str, malloc_check_str ];
keys = orderingMap.keys;
keys = sort( str2double( keys ) );
offsets = sprintf( '\n\t\t/*offsets info for all unique bus structures*/\n' );
for i = 1:length( keys )
offsets = sprintf( [ '%s%s' ], offsets, orderingMap( num2str( keys( i ) ) ) );
end 
busDataDecl = [ busDataDecl, sprintf( '\t%s', offsets ), sprintf( '%s', busPortSizeDecl ) ];
busDataDecl = [ busDataDecl, bus_access_str1 ];


inputIdx = 1;
outputIdx = 1;
idxInputBuses = find( isInBusBased == 1 );
idxOutputBuses = find( isOutBusBased == 1 );
busDeclarationStr = sprintf( '\n\t/* Allocate memory for arrays or nested arrays of buses DWork pointers */\n' );
for i = 1:length( businfoStruct )
isInput = businfoStruct( i ).isinput_port;

if isInput
busName = businfoStruct( i ).bus_structure( 1 ).Name;
isNestedBusArray = businfoStruct( i ).bus_structure( 1 ).isNestedBusArray;
width = prod( InDimsAbs{ idxInputBuses( inputIdx ) } );
tempBusName = sprintf( '_%sBUS', InPortName{ idxInputBuses( inputIdx ) } );
if ( prod( width ) > 1 ) || isNestedBusArray
if ~isempty( busDWorkIdxMap ) && busDWorkIdxMap.isKey( tempBusName( 2:end  ) )
busDeclarationStr = sprintf( [ '%s\t%s** %s = (%s**)ssGetDWork(S,%d);\n' ], busDeclarationStr, busName, tempBusName, busName, busDWorkIdxMap( tempBusName( 2:end  ) ) );
busDeclarationStr = sprintf( [ '%s\t*%s = (%s*)malloc(%d*sizeof(%s));\n' ], busDeclarationStr, tempBusName, busName, width, busName );
terminationCode = sprintf( [ '%s\t\t%s** %s = (%s**)ssGetDWork(S,%d);\n' ], terminationCode, busName, tempBusName, busName, busDWorkIdxMap( tempBusName( 2:end  ) ) );
terminationCode = sprintf( [ '%s\t\tif(*%s != NULL){\n' ], terminationCode, tempBusName );
terminationCode = sprintf( [ '%s\t\t\tfree(*%s);\n\t}\n' ], terminationCode, tempBusName );
terminationCode = sprintf( [ '%s\t\t*%s = NULL;\n' ], terminationCode, tempBusName );
end 
end 

inputIdx = inputIdx + 1;
end 
end 


for i = 1:length( businfoStruct )
isOutput = ~businfoStruct( i ).isinput_port;

if isOutput
busName = businfoStruct( i ).bus_structure( 1 ).Name;
isNestedBusArray = businfoStruct( i ).bus_structure( 1 ).isNestedBusArray;
width = prod( OutDimsAbs{ idxOutputBuses( outputIdx ) } );
tempBusName = sprintf( '_%sBUS', OutPortName{ idxOutputBuses( outputIdx ) } );

if ( prod( width ) > 1 ) || isNestedBusArray
if ~isempty( busDWorkIdxMap ) && busDWorkIdxMap.isKey( tempBusName( 2:end  ) )
busDeclarationStr = sprintf( [ '%s\t%s** %s = (%s**)ssGetDWork(S,%d);\n' ], busDeclarationStr, busName, tempBusName, busName, busDWorkIdxMap( tempBusName( 2:end  ) ) );
busDeclarationStr = sprintf( [ '%s\t*%s = (%s*)malloc(%d*sizeof(%s));\n' ], busDeclarationStr, tempBusName, busName, width, busName );
terminationCode = sprintf( [ '%s\t%s** %s = (%s**)ssGetDWork(S,%d);\n' ], terminationCode, busName, tempBusName, busName, busDWorkIdxMap( tempBusName( 2:end  ) ) );
terminationCode = sprintf( [ '%s\t\tif(*%s != NULL){\n' ], terminationCode, tempBusName );
terminationCode = sprintf( [ '%s\t\t\tfree(*%s);\n\t}\n' ], terminationCode, tempBusName );
terminationCode = sprintf( [ '%s\t\t*%s = NULL;\n' ], terminationCode, tempBusName );
end 
end 

outputIdx = outputIdx + 1;
end 
end 
terminationCode = sprintf( [ '%s}\n' ], terminationCode );
busDataDecl = [ busDataDecl, busDeclarationStr ];







end 



function [ businfoStruct, busPortSizeDecl, orderingMap, offsetStorageStr, dtypeId ] = getOffsets( businfoStruct, SFunMajorityIdx, InDimsAbs, OutDimsAbs, isInBusBased, isOutBusBased )

DataTypeNames = sfbGetBuiltinDataTypeNames(  );

dtypeId = sprintf( '\n' );
maxIdx =  - 1;
orderingMap = containers.Map(  );
keys = businfoStruct( end  ).busVisitedMap.keys;

for i = 1:length( keys )
dtypeId = sprintf( [ '%s\tDTypeId %sId = ssGetDataTypeId(S,"%s");\n' ], dtypeId, keys{ i }, keys{ i } );
end 

for i = 1:length( keys )

infoStruct = businfoStruct( end  ).busVisitedMap( keys{ i } );


for j = 1:length( infoStruct.builtinCIdx )
offsets = sprintf( [ '\tbusInfo[%d].offset   = dtaGetDataTypeElementOffset(dta, bpath, %sId, %d);\n' ],  ...
infoStruct.builtinCIdx( j ), keys{ i }, infoStruct.builtinInBusIdx( j ) - 1 );


datatype_Str = infoStruct.builtinDType{ j };
if ismember( datatype_Str, DataTypeNames )








DT = [ 'SS_', upper( datatype_Str ) ];
offsets = sprintf( [ '%s\tbusInfo[%d].elemSize = dtaGetDataTypeSize(dta, bpath, %s);\n' ],  ...
offsets, infoStruct.builtinCIdx( j ), DT );
else 

if infoStruct.isFpt{ j }


if strcmp( datatype_Str( 1 ), 'c' )
datatype_Str = datatype_Str( 2:end  );
end 

if strcmp( datatype_Str( end  - 1:end  ), '_T' )
offsets = sprintf( [ '%s\tbusInfo[%d].elemSize = dtaGetDataTypeSize(dta, bpath, ssGetDataTypeId(S, "%s"));\n' ],  ...
offsets, infoStruct.builtinCIdx( j ), datatype_Str( 1:end  - 2 ) );
end 
else 
offsets = sprintf( [ '%s\tbusInfo[%d].elemSize = dtaGetDataTypeSize(dta, bpath, ssGetDataTypeId(S, "%s"));\n' ],  ...
offsets, infoStruct.builtinCIdx( j ), datatype_Str );
end 

end 

offsets = sprintf( [ '%s\tbusInfo[%d].numElems = %d;\n' ],  ...
offsets, infoStruct.builtinCIdx( j ), infoStruct.builtinNumElems{ j } );

if ( SFunMajorityIdx == 1 )
offsets = sprintf( [ '%s\tbusInfo[%d].dims = dtaGetDataTypeElementDimensions(dta, bpath, %sId, %d);\n' ],  ...
offsets, infoStruct.builtinCIdx( j ), keys{ i }, infoStruct.builtinInBusIdx( j ) - 1 );
offsets = sprintf( [ '%s\tbusInfo[%d].numDims = dtaGetDataTypeElementNumDimensions(dta, bpath, %sId, %d);\n' ],  ...
offsets, infoStruct.builtinCIdx( j ), keys{ i }, infoStruct.builtinInBusIdx( j ) - 1 );
end 

if maxIdx < infoStruct.builtinCIdx( j )
maxIdx = infoStruct.builtinCIdx( j );
end 

if ~orderingMap.isKey( infoStruct.builtinCIdx( j ) )
orderingMap( num2str( infoStruct.builtinCIdx( j ) ) ) = offsets;
end 

end 


for j = 1:length( infoStruct.busCIdx )

offsets = sprintf( [ '\tbusInfo[%d].offset   = dtaGetDataTypeElementOffset(dta, bpath, %sId, %d);\n' ],  ...
infoStruct.busCIdx( j ), keys{ i }, infoStruct.busInBusIdx( j ) - 1 );

offsets = sprintf( [ '%s\tbusInfo[%d].elemSize = dtaGetDataTypeSize(dta, bpath, %sId);\n' ],  ...
offsets, infoStruct.busCIdx( j ), infoStruct.busDType{ j } );

offsets = sprintf( [ '%s\tbusInfo[%d].numElems = %d;\n' ],  ...
offsets, infoStruct.busCIdx( j ), infoStruct.busNumElems{ j } );

if ( SFunMajorityIdx == 1 )
offsets = sprintf( [ '%s\tbusInfo[%d].dims = dtaGetDataTypeElementDimensions(dta, bpath, %sId, %d);\n' ],  ...
offsets, infoStruct.busCIdx( j ), keys{ i }, infoStruct.busInBusIdx( j ) - 1 );
offsets = sprintf( [ '%s\tbusInfo[%d].numDims = dtaGetDataTypeElementNumDimensions(dta, bpath, %sId, %d);\n' ],  ...
offsets, infoStruct.busCIdx( j ), keys{ i }, infoStruct.busInBusIdx( j ) - 1 );
end 

if maxIdx < infoStruct.busCIdx( j )
maxIdx = infoStruct.busCIdx( j );
end 

if ~orderingMap.isKey( infoStruct.busCIdx( j ) )
orderingMap( num2str( infoStruct.busCIdx( j ) ) ) = offsets;
end 

end 


end 

inIdx = 0;
outIdx = 0;
inBusIdx = find( isInBusBased == 1 );
outBusIdx = find( isOutBusBased == 1 );
busPortSizeDecl = '';
for i = 1:length( businfoStruct )

if businfoStruct( i ).isinput_port
inIdx = inIdx + 1;
else 
outIdx = outIdx + 1;
end 

maxIdx = maxIdx + 1;
busPortSizeDecl = sprintf( [ '%s\tbusInfo[%d].elemSize = dtaGetDataTypeSize(dta, bpath, %sId);\n' ], busPortSizeDecl, maxIdx, businfoStruct( i ).bus_structure( 1 ).Name );
if businfoStruct( i ).isinput_port
if ~isempty( busPortSizeDecl )
busPortSizeDecl = sprintf( [ '%s\tbusInfo[%d].numElems = %d;\n' ], busPortSizeDecl, maxIdx, prod( InDimsAbs{ inBusIdx( inIdx ) } ) );
else 
busPortSizeDecl = sprintf( [ '\tbusInfo[%d].numElems = %d;\n' ], maxIdx, prod( InDimsAbs{ inBusIdx( inIdx ) } ) );
end 
else 
if ~isempty( busPortSizeDecl )
busPortSizeDecl = sprintf( [ '%s\tbusInfo[%d].numElems = %d;\n' ], busPortSizeDecl, maxIdx, prod( OutDimsAbs{ outBusIdx( outIdx ) } ) );
else 
busPortSizeDecl = sprintf( [ '\tbusInfo[%d].numElems = %d;\n' ], maxIdx, prod( OutDimsAbs{ outBusIdx( outIdx ) } ) );
end 
end 
businfoStruct( i ).portInfoCIdx = maxIdx;
end 


offsetStorageStr = sprintf( [ '\n\tbusInfoStruct *busInfo = (busInfoStruct *)malloc(%d*sizeof(busInfoStruct));\n' ], maxIdx + 1 );



end 

function body = genPortDataTypeMethods( NumberOfInputPorts )
inMethods = '';
ssInPDT = '';
if ( NumberOfInputPorts > 0 )
inMethods = [ ( newline ) ...
, '#define MDL_SET_INPUT_PORT_DATA_TYPE', ( newline ) ...
, 'static void mdlSetInputPortDataType(SimStruct *S, int port, DTypeId dType)', ( newline ) ...
, '{', ( newline ) ...
, '    ssSetInputPortDataType(S, 0, dType);', ( newline ) ...
, '}', ( newline ) ...
 ];
ssInPDT = [ '    ssSetInputPortDataType(S, 0, SS_DOUBLE);', ( newline ) ];
end 

outMethods = [ ( newline ) ...
, '#define MDL_SET_OUTPUT_PORT_DATA_TYPE', ( newline ) ...
, 'static void mdlSetOutputPortDataType(SimStruct *S, int port, DTypeId dType)', ( newline ) ...
, '{', ( newline ) ...
, '    ssSetOutputPortDataType(S, 0, dType);', ( newline ) ...
, '}', ( newline ) ...
, ( newline ) ...
, '#define MDL_SET_DEFAULT_PORT_DATA_TYPES', ( newline ) ...
, 'static void mdlSetDefaultPortDataTypes(SimStruct *S)', ( newline ) ...
, '{', ( newline ) ...
, ssInPDT ...
, '    ssSetOutputPortDataType(S, 0, SS_DOUBLE);', ( newline ) ...
, '}', ( newline ) ...
 ];

body = [ inMethods, outMethods ];
end 

function body = writeParamsDeclaration( NumParams, ParameterComplexity, ParameterDataType, ParameterName, FlagGenSFcnBCacheDeclaration )
if ( nargin < 5 )
FlagGenSFcnBCacheDeclaration = true;
end 
body = '';
if ( NumParams > 0 )
body = [ body, sprintf( '    const int_T   p_width%d  = mxGetNumberOfElements(PARAM_DEF%d(S));\n', [ 0:NumParams - 1;0:NumParams - 1 ] ) ];
complexityMask = strcmp( ParameterComplexity, 'COMPLEX_NO' );
paramsIdNum = num2cell( 0:NumParams - 1 );
tempCellToPrint = [ ParameterDataType( complexityMask );ParameterName( complexityMask );ParameterDataType( complexityMask );paramsIdNum( complexityMask ) ];
if ( any( complexityMask ) )
body = [ body, sprintf( '    const %s *%s = (const %s *) mxGetData(PARAM_DEF%d(S));\n', tempCellToPrint{ : } ) ];
end 

complexityMask = strcmp( ParameterComplexity, 'COMPLEX_YES' );
if ( any( complexityMask ) )


if ( FlagGenSFcnBCacheDeclaration )
body = [ body, '    SFcnBCache *c = (SFcnBCache *) ssGetUserData(S);', ( newline ) ];
end 
body = [ body, '    int pIdx;', ( newline ) ];
end 

tempCellToPrint = [ ParameterDataType( complexityMask );ParameterName( complexityMask );ParameterName( complexityMask ) ];
body = [ body, sprintf( '    %s *%s = c->%s;', tempCellToPrint{ : } ) ];
end 

end 

function body = writeParamsDeclaration_cmplx( NumParams, ParameterComplexity, ParameterDataType, ParameterName )
complexityMask = strcmp( ParameterComplexity, 'COMPLEX_YES' );
paramsIdNum = num2cell( 0:NumParams - 1 );

dataTypes = regexprep( ParameterDataType( complexityMask ), '^c', '' );
[ dt, fun ] = cellfun( @getComplexApi, dataTypes, 'UniformOutput', false );
tempCellToPrint = [ ParameterName( complexityMask );
dt;
paramsIdNum( complexityMask );
fun;
paramsIdNum( complexityMask );
paramsIdNum( complexityMask );
ParameterName( complexityMask );
dataTypes;
paramsIdNum( complexityMask );
ParameterName( complexityMask );
dataTypes;
paramsIdNum( complexityMask ) ];
body = '';
if ( any( complexityMask ) )
body = [ sprintf( [ '\n' ...
, '    /* Populate Complex Parameter: %s */\n' ...
, '    %s *pc%d = %s(PARAM_DEF%d(S));\n' ...
, '    for (pIdx = 0; pIdx < p_width%d; pIdx++) {\n' ...
, '        %s[pIdx].re = (%s) pc%d[pIdx].real;\n' ...
, '        %s[pIdx].im = (%s) pc%d[pIdx].imag;\n' ...
, '    }\n' ...
 ], tempCellToPrint{ : } ) ...
, ( newline ) ];
end 
end 

function [ dt, fun ] = getComplexApi( dataType )
switch dataType
case 'real_T'
dt = 'mxComplexDouble';
fun = 'mxGetComplexDoubles';
case 'real32_T'
dt = 'mxComplexSingle';
fun = 'mxGetComplexSingles';
case 'int8_T'
dt = 'mxComplexInt8';
fun = 'mxGetComplexInt8s';
case 'uint8_T'
dt = 'mxComplexUint8';
fun = 'mxGetComplexUint8s';
case 'int16_T'
dt = 'mxComplexInt16';
fun = 'mxGetComplexInt16s';
case 'uint16_T'
dt = 'mxComplexUint16';
fun = 'mxGetComplexUint16s';
case 'int32_T'
dt = 'mxComplexInt32';
fun = 'mxGetComplexInt32s';
case 'uint32_T'
dt = 'mxComplexUint32';
fun = 'mxGetComplexUint32s';
end 
end 

function body = writeSFcnBCache( ParameterComplexity, ParameterDataType, ParameterName, FlagBusUsed )
body = '';
complexityMask = strcmp( ParameterComplexity, 'COMPLEX_YES' );
if ( any( complexityMask ) )
tempCellToPrint = [ ParameterDataType( complexityMask );ParameterName( complexityMask ) ];
body = [ body ...
, ( newline ) ...
, 'typedef struct SFcnBCache_tag {', ( newline ) ...
 ];
body = [ body, sprintf( '    %s *%s;\n', tempCellToPrint{ : } ) ];
if ( FlagBusUsed )
body = [ body ...
, '    busInfoStruct *busInfo;', ( newline ) ...
 ];
end 
body = [ body ...
, '} SFcnBCache;', ( newline ) ...
 ];
end 
end 

function cellOfString = portwidthToString( width )
cellOfString = num2cell( width );
cellOfString = cellfun( @( x )sprintf( '%d', x ), cellOfString, 'UniformOutput', false );
cellOfString( width ==  - 1 ) = { 'DYNAMICALLY_SIZED' };
end 

function strCell = portDimsArray( dimsAbs, getWidthStr )
import matlab.io.internal.text.cell2text
if ~getWidthStr
strCell = cellfun( @( x )strrep( char( cell2text( num2cell( x ) ) ), '-1', 'DYNAMICALLY_SIZED' ), dimsAbs, 'UniformOutput', false );
else 

strCell = cellfun( @( x )num2str( prod( x ) ), dimsAbs, 'UniformOutput', false );
strCell( cellfun( @( x )str2num( x ) < 0, strCell ) ) = { 'DYNAMICALLY_SIZED' };
end 
end 

function printDataTypeDeclaration( fileHandler, NumberOfPorts, PortName, DataType, WordLength, IsSigned, IsBusBased, directionStr, BusNames )
mskFP = strcmp( DataType, 'fixpt' );
mskCFP = strcmp( DataType, 'cfixpt' );
if ( any( ( mskFP | mskCFP ) & WordLength > 64 ) )
DAStudio.error( 'Simulink:SFunctionBuilder:DatatypeLengthExceedsLimit' );
end 
keywordT = cell( 1, NumberOfPorts );
keywordT( ( mskFP | mskCFP ) & WordLength <= 64 ) = { 'int64_T' };
keywordT( ( mskFP | mskCFP ) & WordLength <= 32 ) = { 'int32_T' };
keywordT( ( mskFP | mskCFP ) & WordLength <= 16 ) = { 'int16_T' };
keywordT( ( mskFP | mskCFP ) & WordLength <= 8 ) = { 'int8_T' };
keywordT( ( mskFP | mskCFP ) & ~IsSigned ) = cellfun( @( x )[ 'u', x ], keywordT( ( mskFP | mskCFP ) & ~IsSigned ), 'UniformOutput', false );
keywordT( mskCFP ) = cellfun( @( x )[ 'c', x ], keywordT( mskCFP ), 'UniformOutput', false );
keywordT( ~( mskFP | mskCFP ) & IsBusBased ) = { 'char' };
keywordT( ~( mskFP | mskCFP ) & ~IsBusBased ) = DataType( ~( mskFP | mskCFP ) & ~IsBusBased );
fcnIdentifier = cell( 1, NumberOfPorts );
fcnIdentifier( ( mskFP | mskCFP ) | IsBusBased ) = { [ 'ssGet', directionStr, 'putPortSignal' ] };
fcnIdentifier( ~( mskFP | mskCFP ) & ~IsBusBased ) = { [ 'ssGet', directionStr, 'putPortRealSignal' ] };

tempCellToPrint = [ keywordT;PortName;keywordT;fcnIdentifier;num2cell( 0:NumberOfPorts - 1 ) ];
if ( ~isempty( tempCellToPrint ) )
if ( strcmp( directionStr, 'In' ) )
fprintf( fileHandler, '    const %s *%s = (%s *) %s(S, %d);\n', tempCellToPrint{ : } );
else 
fprintf( fileHandler, '    %s *%s = (%s *) %s(S, %d);\n', tempCellToPrint{ : } );
end 
end 
end 


function tempPortsStr = getDeclarationOfTempPorts( NumberOfPorts, PortName, DataType, WordLength, IsBusBased, IsSigned, IsInput, idxBias )

formatSpecStr = '    %s *%s_t = (%s *)ssGetDWork(S, %d);\n';
tempPortsStr = '';

mskFP = strcmp( DataType, 'fixpt' );
mskCFP = strcmp( DataType, 'cfixpt' );
keywordT = cell( 1, NumberOfPorts );
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & WordLength <= 64 ) = { 'int64_T' };
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & WordLength <= 32 ) = { 'int32_T' };
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & WordLength <= 16 ) = { 'int16_T' };
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & WordLength <= 8 ) = { 'int8_T' };
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & ~IsSigned ) = cellfun( @( x )[ 'u', x ], keywordT( ~IsBusBased & ( mskFP | mskCFP ) & ~IsSigned ), 'UniformOutput', false );
keywordT( ~IsBusBased & mskCFP ) = cellfun( @( x )[ 'c', x ], keywordT( ~IsBusBased & mskCFP ), 'UniformOutput', false );
keywordT( ~IsBusBased & ~( mskFP | mskCFP ) ) = DataType( ~IsBusBased & ~( mskFP | mskCFP ) );
numDWorks = sum( ~IsBusBased );
dworkIdNum = num2cell( ( 0:numDWorks - 1 ) + idxBias );
tempCellToPrint = [ keywordT( ~IsBusBased );PortName( ~IsBusBased );keywordT( ~IsBusBased );dworkIdNum; ];
if ( ~isempty( tempCellToPrint ) )
tempPortsStr = sprintf( formatSpecStr, tempCellToPrint{ : } );
end 

end 

function tempParamStr = getDeclarationOfTempParams( NumParams, ParameterName, ParameterDataType, idxBias )
tempParamStr = '';
tempCellToPrint = [ ParameterDataType;ParameterName;ParameterDataType;num2cell( ( 0:NumParams - 1 ) + idxBias ) ];
if ( ~isempty( tempCellToPrint ) )
tempParamStr = sprintf( '    %s *%s_t = (%s *)ssGetDWork(S, %d);\n', tempCellToPrint{ : } );
end 
end 

function tempPortsStr = getTransposedInputPortsToTemp( NumberOfPorts, PortName, DataType, WordLength, IsBusBased, IsSigned )
tempPortsStr = '';

mskFP = strcmp( DataType, 'fixpt' );
mskCFP = strcmp( DataType, 'cfixpt' );
keywordT = cell( 1, NumberOfPorts );
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & WordLength <= 64 ) = { 'int64_T' };
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & WordLength <= 32 ) = { 'int32_T' };
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & WordLength <= 16 ) = { 'int16_T' };
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & WordLength <= 8 ) = { 'int8_T' };
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & ~IsSigned ) = cellfun( @( x )[ 'u', x ], keywordT( ~IsBusBased & ( mskFP | mskCFP ) & ~IsSigned ), 'UniformOutput', false );
keywordT( ~IsBusBased & mskCFP ) = cellfun( @( x )[ 'c', x ], keywordT( ~IsBusBased & mskCFP ), 'UniformOutput', false );
keywordT( ~IsBusBased & ~( mskFP | mskCFP ) ) = DataType( ~IsBusBased & ~( mskFP | mskCFP ) );
portIdNum = num2cell( 0:NumberOfPorts - 1 );
tempCellToPrint = [ PortName( ~IsBusBased );PortName( ~IsBusBased );portIdNum( ~IsBusBased );portIdNum( ~IsBusBased );keywordT( ~IsBusBased ) ];

if ( ~isempty( tempCellToPrint ) )
tempPortsStr = sprintf( '    NDTransposeBySrcSpecs((void*)%s_t, (const void*)%s, ssGetInputPortDimensions(S, %d), ssGetInputPortNumDimensions(S, %d), sizeof(%s));\n', tempCellToPrint{ : } );
end 

end 

function tempPortsStr = getTransposedOutputPortsFromTemp( NumberOfPorts, PortName, DataType, WordLength, IsBusBased, IsSigned )
tempPortsStr = '';

mskFP = strcmp( DataType, 'fixpt' );
mskCFP = strcmp( DataType, 'cfixpt' );
keywordT = cell( 1, NumberOfPorts );
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & WordLength <= 64 ) = { 'int64_T' };
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & WordLength <= 32 ) = { 'int32_T' };
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & WordLength <= 16 ) = { 'int16_T' };
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & WordLength <= 8 ) = { 'int8_T' };
keywordT( ~IsBusBased & ( mskFP | mskCFP ) & ~IsSigned ) = cellfun( @( x )[ 'u', x ], keywordT( ~IsBusBased & ( mskFP | mskCFP ) & ~IsSigned ), 'UniformOutput', false );
keywordT( ~IsBusBased & mskCFP ) = cellfun( @( x )[ 'c', x ], keywordT( ~IsBusBased & mskCFP ), 'UniformOutput', false );
keywordT( ~IsBusBased & ~( mskFP | mskCFP ) ) = DataType( ~IsBusBased & ~( mskFP | mskCFP ) );
portIdNum = num2cell( 0:NumberOfPorts - 1 );
tempCellToPrint = [ PortName( ~IsBusBased );PortName( ~IsBusBased );portIdNum( ~IsBusBased );portIdNum( ~IsBusBased );keywordT( ~IsBusBased ) ];

if ( ~isempty( tempCellToPrint ) )
tempPortsStr = sprintf( '    NDTransposeByDstSpecs((void*)%s, (const void*)%s_t, ssGetOutputPortDimensions(S, %d), ssGetOutputPortNumDimensions(S, %d), sizeof(%s));\n', tempCellToPrint{ : } );
end 

end 

function tempPortsStr = getTransposedParametersToTemp( NumParams, ParameterName, ParameterDataType )
tempPortsStr = '';
portIdNum = num2cell( 0:NumParams - 1 );
tempCellToPrint = [ ParameterName;ParameterName;portIdNum;portIdNum;ParameterDataType ];
if ( ~isempty( tempCellToPrint ) )
tempPortsStr = sprintf( '    NDTransposeBySrcSpecs((void*)%s_t, (const void*)%s, mxGetDimensions(PARAM_DEF%d(S)), mxGetNumberOfDimensions(PARAM_DEF%d(S)), sizeof(%s));\n', tempCellToPrint{ : } );
end 

end 

function transposeCodeForNonBusData = getTransposeCodeForNonBusTypeData( NumberOfInputPorts, InPortName, InDataType, InWordLength, IsInBusBased, InIsSigned,  ...
NumberOfOutputPorts, OutPortName, OutDataType, OutWordLength, IsOutBusBased, OutIsSigned, NumInDWork,  ...
NumParams, ParameterName, ParameterDataType, NumOutDWork, SFunMajorityIndex, directFeed, IsOutputMethod )
transposeCodeForNonBusData = struct(  ...
'commentDataTranspose', '',  ...
'declareInputTranspose', '',  ...
'declareOutputTranspose', '',  ...
'declareParamTranspose', '',  ...
'dataCopyInputTranspose', '',  ...
'dataCopyParamTranspose', '',  ...
'dataCopyOutputTranspose', '' );
if ( SFunMajorityIndex == 1 )
transposeCodeForNonBusData.commentDataTranspose = [ '    /* S-Function Builder Row Major Support has been enabled for custom', ( newline ) ...
, '     * code, a transposed copy will be created for any array signals.', ( newline ) ...
, '     */', ( newline ) ];
if ( directFeed || ~IsOutputMethod )
transposeCodeForNonBusData.declareInputTranspose = getDeclarationOfTempPorts( NumberOfInputPorts, InPortName, InDataType, InWordLength, IsInBusBased, InIsSigned, true, 0 );
transposeCodeForNonBusData.dataCopyInputTranspose = getTransposedInputPortsToTemp( NumberOfInputPorts, InPortName, InDataType, InWordLength, IsInBusBased, InIsSigned );
end 

transposeCodeForNonBusData.declareOutputTranspose = getDeclarationOfTempPorts( NumberOfOutputPorts, OutPortName, OutDataType, OutWordLength, IsOutBusBased, OutIsSigned, false, NumInDWork );
transposeCodeForNonBusData.declareParamTranspose = getDeclarationOfTempParams( NumParams, ParameterName, ParameterDataType, NumInDWork + NumOutDWork );

transposeCodeForNonBusData.dataCopyParamTranspose = getTransposedParametersToTemp( NumParams, ParameterName, ParameterDataType );
transposeCodeForNonBusData.dataCopyOutputTranspose = getTransposedOutputPortsFromTemp( NumberOfOutputPorts, OutPortName, OutDataType, OutWordLength, IsOutBusBased, OutIsSigned );
end 

end 

function registerFixedPointDataTypeForInt64( fileHandler, DataTypeMacro, i0, FlagIn )

if ( FlagIn )
port = 'IN';
else 
port = 'OUT';
end 

fprintf( fileHandler, ' { DTypeId %s_%d = ssRegisterDataTypeInteger(\n', DataTypeMacro, i0 );
fprintf( fileHandler, '            S,\n' );
fprintf( fileHandler, [ '            ', port, '_%d_ISSIGNED,\n' ], i0 );
fprintf( fileHandler, '            64,\n' );
fprintf( fileHandler, '            0 );\n' );
end 

function registerFixedPointDataType( fileHandler, DataTypeMacro, i0, FlagFixPointScaling, FlagIn )

if ( FlagIn )
port = 'IN';
else 
port = 'OUT';
end 

if ( FlagFixPointScaling )
fprintf( fileHandler, ' { DTypeId %s_%d = ssRegisterDataTypeFxpSlopeBias(\n', DataTypeMacro, i0 );
fprintf( fileHandler, '            S,\n' );
fprintf( fileHandler, [ '            ', port, '_%d_ISSIGNED,\n' ], i0 );
fprintf( fileHandler, [ '            ', port, '_%d_WORDLENGTH,\n' ], i0 );
fprintf( fileHandler, [ '            ', port, '_%d_SLOPE,\n' ], i0 );
fprintf( fileHandler, [ '            ', port, '_%d_BIAS,\n' ], i0 );
fprintf( fileHandler, '            0 );\n' );
else 
fprintf( fileHandler, ' { DTypeId %s_%d = ssRegisterDataTypeFxpBinaryPoint(\n', DataTypeMacro, i0 );
fprintf( fileHandler, '            S,\n' );
fprintf( fileHandler, [ '            ', port, '_%d_ISSIGNED,\n' ], i0 );
fprintf( fileHandler, [ '            ', port, '_%d_WORDLENGTH,\n' ], i0 );
fprintf( fileHandler, [ '            ', port, '_%d_FRACTIONLENGTH,\n' ], i0 );
fprintf( fileHandler, '            0 );\n' );
end 
end 


% Decoded using De-pcode utility v1.2 from file /tmp/tmpZDEHxl.p.
% Please follow local copyright laws when handling this file.

