function writeTlcBlockTypeSetup( h, fid, infoStruct )





headerFiles = legacycode.util.lct_pCollectAllHeaderFiles( infoStruct );

fprintf( fid, '%%%% Function: BlockTypeSetup ===============================================\n' );
fprintf( fid, '%%%%\n' );
fprintf( fid, '%%function BlockTypeSetup(block, system) void\n' );
fprintf( fid, '  %%%%\n' );


if infoStruct.isCPP == false
fprintf( fid, '  %%%% The Target Language must be C\n' );
fprintf( fid, '  %%if ::GenCPP==1\n' );
fprintf( fid, [ '    %%<LibReportFatalError("This S-Function generated by ',  ...
'the Legacy Code Tool must be only used with the C Target Language")>\n' ] );
fprintf( fid, '  %%endif\n' );
else 
fprintf( fid, '  %%%% The Target Language must be C++\n' );
fprintf( fid, '  %%if ::GenCPP==0 && !IsModelReferenceSimTarget()\n' );
fprintf( fid, [ '    %%<LibReportFatalError("This S-Function generated by ',  ...
'the Legacy Code Tool must be only used with the C++ Target Language")>\n' ] );
fprintf( fid, '  %%endif\n' );
end 
fprintf( fid, '\n' );




if infoStruct.hasWrapper || infoStruct.isCPP
infoStruct.INDENT_SPACE = '  ';

h.writeUserDefinedHeaderIf( fid, infoStruct );
fprintf( fid, '\n' );




fprintf( fid, '    %%assign hFileName = FcnGenerateUniqueFileName("%s_wrapper", "header")\n', infoStruct.Specs.SFunctionName );
fprintf( fid, '    %%assign hFileNameMacro = FEVAL("upper", hFileName)\n' );
fprintf( fid, '    %%openfile hFile = "%%<hFileName>.h"\n' );
fprintf( fid, '    %%selectfile hFile\n' );
fprintf( fid, '    #ifndef _%%<hFileNameMacro>_H_\n' );
fprintf( fid, '    #define _%%<hFileNameMacro>_H_\n' );


fprintf( fid, '\n' );
fprintf( fid, '    #ifdef MATLAB_MEX_FILE\n' );
fprintf( fid, '    #include "tmwtypes.h"\n' );
fprintf( fid, '    #else\n' );
fprintf( fid, '    #include "rtwtypes.h"\n' );
fprintf( fid, '    #endif\n' );
fprintf( fid, '\n' );


[ memFcnDecl, memFcnDef ] = iGeneratePWorkAllocFreeFcn( infoStruct );
if ~isempty( memFcnDecl )
fprintf( fid, '%s\n', memFcnDecl );
end 


fcnMap = {  ...
'InitializeConditions', 'initialize_conditions'; ...
'Start', 'start'; ...
'Output', 'output'; ...
'Terminate', 'terminate' ...
 };


for ii = 1:size( fcnMap, 1 )
fcn = fcnMap{ ii, 1 };
if infoStruct.Fcns.( fcn ).IsSpecified
fprintf( fid, '    extern %s;\n',  ...
h.generateTlcFcnWrapperProtoString( infoStruct, infoStruct.Fcns.( fcn ), fcnMap{ ii, 2 } ) );
fprintf( fid, '\n' );
end 
end 

fprintf( fid, '    #endif\n' );
fprintf( fid, '    %%closefile hFile\n' );
fprintf( fid, '\n' );



if infoStruct.isCPP == false
fExt = 'c';
else 
fExt = 'cpp';
end 
fprintf( fid, '    %%assign cFileName = FcnGenerateUniqueFileName("%s_wrapper", "source")\n', infoStruct.Specs.SFunctionName );
fprintf( fid, '    %%openfile cFile = "%%<cFileName>.%s"\n', fExt );
fprintf( fid, '    %%selectfile cFile\n' );


if infoStruct.DWorks.NumDWorkForBus > 0
fprintf( fid, '    #include <stdlib.h>\n' );
end 
fprintf( fid, '    #include <string.h>\n' );
fprintf( fid, '    #ifdef MATLAB_MEX_FILE\n' );
fprintf( fid, '    #include "tmwtypes.h"\n' );
fprintf( fid, '    #else\n' );
fprintf( fid, '    #include "rtwtypes.h"\n' );
fprintf( fid, '    #endif\n' );


if ~isempty( headerFiles.GlobalHeaderFiles )
for ii = 1:length( headerFiles.GlobalHeaderFiles )
thisHeaderFile = headerFiles.GlobalHeaderFiles{ ii };
dblQuote = '"';
if thisHeaderFile( 1 ) == '<' || thisHeaderFile( 1 ) == '"'
dblQuote = '';
end 
fprintf( fid, '    #include %s%s%s\n', dblQuote, thisHeaderFile, dblQuote );
end 
end 


if ~isempty( headerFiles.SlObjHeaderFiles )
for ii = 1:length( headerFiles.SlObjHeaderFiles )
thisHeaderFile = headerFiles.SlObjHeaderFiles{ ii };
dblQuote = '"';
if thisHeaderFile( 1 ) == '<' || thisHeaderFile( 1 ) == '"'
dblQuote = '';
end 
fprintf( fid, '    #include %s%s%s\n', dblQuote, thisHeaderFile, dblQuote );
end 
end 

fprintf( fid, '\n' );


externCStartTxt = '';
externCEndTxt = '';
if infoStruct.isCPP == true
externCStartTxt = sprintf( '    extern "C" {\n' );
externCEndTxt = sprintf( '    }\n' );




if infoStruct.hasWrapper
externCStartTxt = sprintf( '    %%if IsModelReferenceSimTarget()\n%s    %%endif\n',  ...
externCStartTxt );
externCEndTxt = sprintf( '    %%if IsModelReferenceSimTarget()\n%s    %%endif\n',  ...
externCEndTxt );
end 
end 


if ~isempty( memFcnDef )
fprintf( fid, '%s', externCStartTxt );
fprintf( fid, '%s\n\n', memFcnDef );
fprintf( fid, '%s', externCEndTxt );
end 


for ii = 1:size( fcnMap, 1 )
fcnSpec = infoStruct.Fcns.( fcnMap{ ii, 1 } );
fcnImp = fcnMap{ ii, 2 };
if fcnSpec.IsSpecified
fprintf( fid, '%s', externCStartTxt );

fprintf( fid, '    %s {\n', h.generateTlcFcnWrapperProtoString( infoStruct, fcnSpec, fcnImp ) );
h.writeTlcTempVariableForUserStruct( fid, infoStruct, fcnSpec );
fprintf( fid, '\n' );
if infoStruct.has2DMatrix
h.writeTlcTempVariableFor2DMatrix( fid, infoStruct, fcnSpec, true );
fprintf( fid, '\n' );
end 

h.writeTlcAssignSLStructToUserStruct( fid, infoStruct, fcnSpec );

if infoStruct.has2DMatrix
h.writeTlc2DMatrixConversion( fid, infoStruct, fcnSpec, true );
end 

fprintf( fid, '\n      %s;\n\n', h.generateTlcFcnCallInWrapperString( infoStruct, fcnSpec ) );

if infoStruct.has2DMatrix
h.writeTlc2DMatrixConversion( fid, infoStruct, fcnSpec, false );
end 

h.writeTlcAssignUserStructToSLStruct( fid, infoStruct, fcnSpec );

fprintf( fid, '    }\n' );

fprintf( fid, '%s', externCEndTxt );

fprintf( fid, '\n' );
end 
end 

fprintf( fid, '    %%closefile cFile\n' );
fprintf( fid, '\n' );


fprintf( fid, '    %%<LibAddToCommonIncludes("%%<hFileName>.h")>\n' );



if infoStruct.isCPP == false

fprintf( fid, '    %%<LibAddToModelSources("%%<cFileName>")>\n' );

else 


fprintf( fid, '    %%if IsModelReferenceSimTarget()\n' );
fprintf( fid, '        %%<SLibAddToStaticSources("%%<cFileName>.cpp")>\n' );
fprintf( fid, '    %%else\n' );
fprintf( fid, '        %%<LibAddToModelSources("%%<cFileName>")>\n' );
fprintf( fid, '    %%endif\n' );
end 

fprintf( fid, '\n' );
fprintf( fid, '  %%else\n' );
fprintf( fid, '\n' );
end 


h.writeTlcAddToHeaderFilesListing( fid, headerFiles.GlobalHeaderFiles, infoStruct.INDENT_SPACE );



h.writeTlcAddToHeaderFilesListing( fid, headerFiles.SlObjHeaderFiles, infoStruct.INDENT_SPACE );


if infoStruct.hasWrapper || infoStruct.isCPP
fprintf( fid, '\n' );
fprintf( fid, '  %%endif\n' );
fprintf( fid, '\n' );
end 



h.writeTlcAddToSourceFilesListing( fid, infoStruct.Specs.SourceFiles, infoStruct.INDENT_SPACE );

fprintf( fid, '\n' );
fprintf( fid, '  %%%%\n' );
fprintf( fid, '%%endfunction\n' );
fprintf( fid, '\n' );

end 


function [ memFcnDecl, memFcnDef ] = iGeneratePWorkAllocFreeFcn( infoStruct )

memFcnDecl = '';
memFcnDef = '';

if infoStruct.DWorks.NumDWorkForBus < 1

return 
end 

allocProto = sprintf( 'int %s_wrapper_allocmem(', infoStruct.Specs.SFunctionName );
freeProto = sprintf( 'int %s_wrapper_freemem(', infoStruct.Specs.SFunctionName );

allocBody = '';
freeBody = '';
sep = '';

for ii = 1:infoStruct.DWorks.NumDWorkForBus

thisDWork = infoStruct.DWorks.DWorkForBus( ii );
thisDataType = infoStruct.DataTypes.DataType( thisDWork.DataTypeId );

thisDataType.DTName;

allocProto = sprintf( '%s%svoid** __%sBUS, int_T __%sWidth', allocProto, sep,  ...
thisDWork.Identifier, thisDWork.Identifier );

allocBody = sprintf( '%s\n      *__%sBUS = calloc(sizeof(%s), __%sWidth);\n', allocBody,  ...
thisDWork.Identifier, thisDataType.DTName, thisDWork.Identifier );
allocBody = sprintf( '%s      if (*__%sBUS==NULL) return -1;\n', allocBody, thisDWork.Identifier );

freeProto = sprintf( '%s%svoid** __%sBUS', freeProto, sep,  ...
thisDWork.Identifier );

freeBody = sprintf( '%s\n      if (*__%sBUS!=NULL) free(*__%sBUS);\n      *__%sBUS = NULL;\n', freeBody,  ...
thisDWork.Identifier, thisDWork.Identifier, thisDWork.Identifier );

sep = ', ';
end 

memFcnDecl = sprintf( '    extern %s);\n    extern %s);\n', allocProto, freeProto );
memFcnDef = sprintf( '    %s) {%s\n      return 0;\n    }\n\n    %s) {%s\n      return 0;\n    }',  ...
allocProto, allocBody, freeProto, freeBody );
end 





% Decoded using De-pcode utility v1.2 from file /tmp/tmptYZlzx.p.
% Please follow local copyright laws when handling this file.

