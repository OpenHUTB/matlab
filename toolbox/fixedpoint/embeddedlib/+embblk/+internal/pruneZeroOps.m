function pruneZeroOps(blk)




    if strcmpi(get_param(bdroot(blk),'Dirty'),'on')
        set_param(bdroot(blk),'SimulationCommand','Update');
    end


    refBlk=get_param(blk,"ReferenceBlock");
    blkAddr=split(refBlk,"/");
    blkType=blkAddr(end);
    dict=getBlockPathDictionary;
    blkPathInfo=dict(blkType);

    suppressedDiagnostics=Simulink.getSuppressedDiagnostics(blk);
    diagnosticSource={suppressedDiagnostics.Source};
    diagnosticIds={suppressedDiagnostics.Id};

    breakLinks(blk,blkPathInfo);

    blkDescriptor=fixed.emblib.internal.slutil.BlockLibrary(blkPathInfo.Unit);
    forEachParent=strip(blk+"/"+blkPathInfo.ForEachParent,"/");
    subsystemCreator=fixed.emblib.internal.slutil.SubsystemCreator.forNewSubsystem(...
    forEachParent,blkPathInfo.SubsystemName,blkDescriptor.getNumInputs(),...
    blkDescriptor.getInputNames(),blkDescriptor.getNumOutputs(),...
    blkDescriptor.getOutputNames());
    numStages=getNumStages(blk,blkType);
    numOutputs=blkDescriptor.getNumOutputs();
    numMatrixOutputs=blkPathInfo.NumMatrixOutputs;
    [concatOptions(1:numOutputs).NumInputs]=deal(string(numStages));
    [concatOptions(1:numMatrixOutputs).Mode]=deal("Multidimensional array");
    [concatOptions(1:numMatrixOutputs).ConcatenateDimension]=deal("2");
    [concatOptions((numMatrixOutputs+1):end).Mode]=deal("Vector");
    [concatOptions((numMatrixOutputs+1):end).ConcatenateDimension]=deal("2");
    stagePrototype=fixed.emblib.internal.slutil.ComputationAtom(blkDescriptor);
    loopUnroller=fixed.emblib.internal.slutil.ParameterizedLoopUnroll(numStages,stagePrototype,concatOptions);

    forEachParent=strip(blk+"/"+blkPathInfo.ForEachParent,"/");
    forEachPath=strip(forEachParent,"/")+"/"+blkPathInfo.ForEachName;
    mask=Simulink.Mask.get(forEachParent);
    for ii=1:length(mask.Parameters)
        loopUnroller=loopUnroller.addConstantParam(mask.Parameters(ii).Name,mask.Parameters(ii).Value);
    end

    loopUnroller=loopUnroller.addUnrolledParam("k",string(1:numStages));
    loopUnroller=loopUnroller.makeParamPack();
    loopUnroller=loopUnroller.makeOutputConcatenator();
    loopUnroller=loopUnroller.acceptCreator(subsystemCreator);
    loopUnroller.connectOutputs();
    internalInputInterface=fixed.emblib.internal.slutil.SubsystemInternalIOInterface(subsystemCreator.getFullPath(),"Input");
    internalOutputInterface=fixed.emblib.internal.slutil.SubsystemInternalIOInterface(subsystemCreator.getFullPath(),"Output");
    loopUnroller.connectToSystemInterface(internalInputInterface,internalOutputInterface);
    Simulink.BlockDiagram.arrangeSystem(subsystemCreator.getFullPath());


    pos=get_param(forEachPath,"Position");
    delete_block(forEachPath);
    set_param(subsystemCreator.getFullPath(),"Position",pos);
    delete_block(forEachParent+"/pivots");
    delete_block(forEachParent+"/Select A");

    unconnectedLineHandles=find_system(forEachParent,...
    "FindAll","on","LookUnderMasks","on","type","line","Connected","off");
    delete_line(unconnectedLineHandles);


    add_line(forEachParent,blkPathInfo.PostPlaceLineSource,blkPathInfo.PostPlaceLineTarget);



    for ii=1:length(diagnosticSource)
        try %#ok<TRYNC> 


            Simulink.SuppressedDiagnostic(diagnosticSource{ii},diagnosticIds{ii});
        end
    end

end

function dict=getBlockPathDictionary()

    dict=dictionary();

    dict("Complex Partial-Systolic QR Decomposition")=...
    struct("ForEachParent",...
    "Complex Partial-Systolic QR Decomposition Internal",...
    "ForEachName",...
    "Complex Partial-Systolic QR For-Each Subsystem",...
    "Unit",...
    "Complex Partial-Systolic QR Stage",...
    "SubsystemName",...
    "Complex Partial-Systolic QR Decomposition Unrolled For-Each",...
    "NumMatrixOutputs",...
    2,...
    "PostPlaceLineSource",...
    {{"Concatenate A/1","Reshape A/1","Reshape B/1","Select validIn/1","Compare/1","restartExtension/1"}},...
    "PostPlaceLineTarget",...
    {[{"Reshape A/1"},arrayfun(@(x)"Complex Partial-Systolic QR Decomposition Unrolled For-Each/"+string(x),1:5,'UniformOutput',false)]});%#ok<*CLARRSTR> 

    dict("Real Partial-Systolic QR Decomposition")=...
    struct("ForEachParent",...
    "Real Partial-Systolic QR Decomposition Internal",...
    "ForEachName",...
    "Real Partial-Systolic QR For-Each Subsystem",...
    "Unit",...
    "Real Partial-Systolic QR Stage",...
    "SubsystemName",...
    "Real Partial-Systolic QR Decomposition Unrolled For-Each",...
    "NumMatrixOutputs",...
    2,...
    "PostPlaceLineSource",...
    {{"Concatenate A/1","Reshape A/1","Reshape B/1","Select validIn/1","Compare/1","restartExtension/1"}},...
    "PostPlaceLineTarget",...
    {[{"Reshape A/1"},arrayfun(@(x)"Real Partial-Systolic QR Decomposition Unrolled For-Each/"+string(x),1:5,'UniformOutput',false)]});

    dict("Complex Partial-Systolic Q-less QR Decomposition")=...
    struct("ForEachParent",...
    "",...
    "ForEachName",...
    "Complex Partial-Systolic Q-less QR For-Each Subsystem",...
    "Unit",...
    "Complex Partial-Systolic Q-less QR Stage",...
    "SubsystemName",...
    sprintf("Complex Partial-Systolic Q-less QR Decomposition\nUnrolled For-Each"),...
    "NumMatrixOutputs",...
    1,...
    "PostPlaceLineSource",...
    {{"Concatenate A/1","Reshape A/1","Reshape validIn/1","restartExtension/1"}},...
    "PostPlaceLineTarget",...
    {[{"Reshape A/1"},arrayfun(@(x)sprintf("Complex Partial-Systolic Q-less QR Decomposition\nUnrolled For-Each/")+string(x),1:3,"UniformOutput",false)]});

    dict("Real Partial-Systolic Q-less QR Decomposition")=...
    struct("ForEachParent",...
    "",...
    "ForEachName",...
    "Real Partial-Systolic Q-less QR For-Each Subsystem",...
    "Unit",...
    "Real Partial-Systolic Q-less QR Stage",...
    "SubsystemName",...
    "Real Partial-Systolic Q-less QR Decomposition\nUnrolled For-Each",...
    "NumMatrixOutputs",...
    1,...
    "PostPlaceLineSource",...
    {{"Concatenate A/1","Reshape A/1","Reshape validIn/1","restartExtension/1"}},...
    "PostPlaceLineTarget",...
    {[{"Reshape A/1"},arrayfun(@(x)"Real Partial-Systolic Q-less QR Decomposition\nUnrolled For-Each/"+string(x),1:3,"UniformOutput",false)]});



































    dict("Complex Partial-Systolic Matrix Solve Using QR Decomposition")=...
    struct("ForEachParent",...
    "Complex Partial-Systolic QR Decomposition Internal",...
    "ForEachName",...
    "Complex Partial-Systolic QR For-Each Subsystem",...
    "Unit",...
    "Complex Partial-Systolic QR Stage",...
    "SubsystemName",...
    "Complex Partial-Systolic QR Decomposition Unrolled For-Each",...
    "NumMatrixOutputs",...
    2,...
    "PostPlaceLineSource",...
    {{"Concatenate A/1","Reshape A/1","Reshape B/1","Select validIn/1","Compare/1","restartExtension/1"}},...
    "PostPlaceLineTarget",...
    {[{"Reshape A/1"},arrayfun(@(x)"Complex Partial-Systolic QR Decomposition Unrolled For-Each/"+string(x),1:5,'UniformOutput',false)]});%#ok<*CLARRSTR> 


    dict("Real Partial-Systolic Matrix Solve Using QR Decomposition")=...
    struct("ForEachParent",...
    "Real Partial-Systolic QR Decomposition",...
    "ForEachName",...
    "Real Partial-Systolic QR For-Each Subsystem",...
    "Unit",...
    "Real Partial-Systolic QR Stage",...
    "SubsystemName",...
    "Real Partial-Systolic QR Decomposition Unrolled For-Each",...
    "NumMatrixOutputs",...
    2,...
    "PostPlaceLineSource",...
    {{"Concatenate A/1","Reshape A/1","Reshape B/1","Select validIn/1","Compare/1","restartExtension/1"}},...
    "PostPlaceLineTarget",...
    {[{"Reshape A/1"},arrayfun(@(x)"Real Partial-Systolic QR Decomposition Unrolled For-Each/"+string(x),1:5,'UniformOutput',false)]});

    dict("Complex Partial-Systolic Matrix Solve Using Q-less QR Decomposition")=...
    struct("ForEachParent",...
    "Complex Partial-Systolic Q-less QR Decomposition",...
    "ForEachName",...
    "Complex Partial-Systolic Q-less QR For-Each Subsystem",...
    "Unit",...
    "Complex Partial-Systolic Q-less QR Stage",...
    "SubsystemName",...
    sprintf("Complex Partial-Systolic Q-less QR Decomposition\nUnrolled For-Each"),...
    "NumMatrixOutputs",...
    1,...
    "PostPlaceLineSource",...
    {{"Concatenate A/1","Reshape A/1","Reshape validIn/1","restartExtension/1"}},...
    "PostPlaceLineTarget",...
    {[{"Reshape A/1"},arrayfun(@(x)sprintf("Complex Partial-Systolic Q-less QR Decomposition\nUnrolled For-Each/")+string(x),1:3,"UniformOutput",false)]});

    dict("Real Partial-Systolic Matrix Solve Using Q-less QR Decomposition")=...
    struct("ForEachParent",...
    "Real Partial-Systolic Q-less QR Decomposition",...
    "ForEachName",...
    "Real Partial-Systolic Q-less QR For-Each Subsystem",...
    "Unit",...
    "Real Partial-Systolic Q-less QR Stage",...
    "SubsystemName",...
    "Real Partial-Systolic Q-less QR Decomposition\nUnrolled For-Each",...
    "NumMatrixOutputs",...
    1,...
    "PostPlaceLineSource",...
    {{"Concatenate A/1","Reshape A/1","Reshape validIn/1","restartExtension/1"}},...
    "PostPlaceLineTarget",...
    {[{"Reshape A/1"},arrayfun(@(x)"Real Partial-Systolic Q-less QR Decomposition\nUnrolled For-Each/"+string(x),1:3,"UniformOutput",false)]});

end

function breakLinks(blk,blkPathInfo)

    cumulativePath=blk;
    function newPath=reducer(nextPathStep)
        newPath=cumulativePath+"/"+nextPathStep;
        cumulativePath=newPath;
    end

    pathSteps=split(blkPathInfo.ForEachParent,"/");
    reducedPath=arrayfun(@(x)reducer(x),pathSteps);
    set_param(blk,"LinkStatus","none");
    for ii=1:length(reducedPath)
        set_param(reducedPath(ii),"LinkStatus","none");
    end

end



function numStages=getNumStages(blk,blkType)

    wsVars=get_param(blk,'MaskWSVariables');
    nIdx=strcmp({wsVars.Name},'n');
    mIdx=strcmp({wsVars.Name},'m');
    if any(string(blkType)==["Complex Partial-Systolic Q-less QR with Forgetting Factor",...
        "Real Partial-Systolic Q-less QR with Forgetting Factor"])
        numStages=wsVars(nIdx).Value;
    else
        m=wsVars(mIdx).Value;
        n=wsVars(nIdx).Value;
        numStages=min(m,n);
    end


end
